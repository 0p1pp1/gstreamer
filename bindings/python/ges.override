/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>

#include <gst/gst.h>
#include <ges/ges.h>

#include <glib.h>
#include <pyglib.h>


#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

/* Boonky define that allows for backwards compatibility with Python 2.4 */
#if PY_VERSION_HEX < 0x02050000
#define Py_ssize_t int
#endif

void pyges_register_classes(PyObject *d);
void pyges_add_constants(PyObject *module, const gchar *strip_prefix);

%%
import gobject.GObject as PyGObject_Type
import gobject.MainContext as PyGMainContext_Type
import gobject.GObject as PyGInitiallyUnowned_Type
import gst.Bin as PyGstBin_Type
import gst.Pipeline as PyGstPipeline_Type

%%
override ges_track_get_timeline kwargs
static PyObject *
_wrap_ges_track_get_timeline(PyGObject *self)
{
    const GESTimeline *ret;

    pyg_begin_allow_threads;
    ret = ges_track_get_timeline(GES_TRACK(self->obj));
    pyg_end_allow_threads;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

%%
override ges_timeline_get_tracks noargs
static PyObject *
_wrap_ges_timeline_get_tracks(PyGObject *self)
{
    const GList *l, *list;
    PyObject *py_list;

    g_return_val_if_fail (GES_IS_TIMELINE (self->obj), PyList_New(0));

    pyg_begin_allow_threads;
    list = ges_timeline_get_tracks(GES_TIMELINE(self->obj));
    pyg_end_allow_threads;

    py_list = PyList_New(0);
    for (l = list; l; l = l->next) {
    GESTrack *track = (GESTrack*)l->data;
    PyObject *py_track = pygobject_new(G_OBJECT(track));
    PyList_Append(py_list, py_track);
    Py_DECREF(py_track);
    }

    return py_list;
}

%%
override ges_timeline_parse_launch_effect_new kwargs
static int
_wrap_ges_timeline_parse_launch_effect_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "video_bin_description", "audio_bin_description", NULL };
    char *video_bin_description, *audio_bin_description = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"zz:GES.TimelineParseLaunchEffect.__init__", kwlist, &video_bin_description, &audio_bin_description))
        return -1;
    self->obj = (GObject *)ges_timeline_parse_launch_effect_new(video_bin_description, audio_bin_description);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GESTimelineParseLaunchEffect object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

%%
override ges_timeline_get_layers noargs
static PyObject *
_wrap_ges_timeline_get_layers(PyGObject *self)
{
    const GList *l, *list;
    PyObject *py_list;

    g_return_val_if_fail (GES_IS_TIMELINE (self->obj), PyList_New(0));

    pyg_begin_allow_threads;
    list = ges_timeline_get_layers(GES_TIMELINE(self->obj));
    pyg_end_allow_threads;

    py_list = PyList_New(0);
    for (l = list; l; l = l->next) {
    GESTimelineLayer *layer = (GESTimelineLayer*)l->data;
    PyObject *py_layer = pygobject_new(G_OBJECT(layer));
    PyList_Append(py_list, py_layer);
    Py_DECREF(py_layer);
    }

    return py_list;
}

%%
override ges_timeline_layer_get_objects noargs
static PyObject *
_wrap_ges_timeline_layer_get_objects(PyGObject *self)
{
    const GList *l, *list;
    PyObject *py_list;

    g_return_val_if_fail (GES_IS_TIMELINE_LAYER (self->obj), PyList_New(0));

    pyg_begin_allow_threads;
    list = ges_timeline_layer_get_objects(GES_TIMELINE_LAYER(self->obj));
    pyg_end_allow_threads;

    py_list = PyList_New(0);
    for (l = list; l; l = l->next) {
    GESTimelineObject *object = (GESTimelineObject*)l->data;
    PyObject *py_object = pygobject_new(G_OBJECT(object));
    PyList_Append(py_list, py_object);
    Py_DECREF(py_object);
    }

    return py_list;
}

%%
override ges_timeline_object_get_track_objects noargs
static PyObject *
_wrap_ges_timeline_object_get_track_objects(PyGObject *self)
{
    const GList *l, *list;
    PyObject *py_list;

    g_return_val_if_fail (GES_IS_TIMELINE_OBJECT (self->obj), PyList_New(0));

    pyg_begin_allow_threads;
    list = ges_timeline_object_get_track_objects(GES_TIMELINE_OBJECT(self->obj));
    pyg_end_allow_threads;

    py_list = PyList_New(0);
    for (l = list; l; l = l->next) {
    GESTrackObject *object = (GESTrackObject*)l->data;
    PyObject *py_object = pygobject_new(G_OBJECT(object));
    PyList_Append(py_list, py_object);
    Py_DECREF(py_object);
    }

    return py_list;
}

%%
ignore-glob

  *_get_type
