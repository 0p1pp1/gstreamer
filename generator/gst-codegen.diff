diff -Naur generator-upstream/BoxedGen.cs generator/BoxedGen.cs
--- generator-upstream/BoxedGen.cs	2009-01-04 23:29:56.000000000 +0100
+++ generator/BoxedGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -40,16 +40,16 @@
 
 			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
 			base.Generate (gen_info);
-			sw.WriteLine ("\t\tpublic static explicit operator GLib.Value (" + QualifiedName + " boxed)");
+			sw.WriteLine ("\t\tpublic static explicit operator Gst.GLib.Value (" + QualifiedName + " boxed)");
 			sw.WriteLine ("\t\t{");
 
-			sw.WriteLine ("\t\t\tGLib.Value val = GLib.Value.Empty;");
+			sw.WriteLine ("\t\t\tGst.GLib.Value val = Gst.GLib.Value.Empty;");
 			sw.WriteLine ("\t\t\tval.Init (" + QualifiedName + ".GType);");
 			sw.WriteLine ("\t\t\tval.Val = boxed;");
 			sw.WriteLine ("\t\t\treturn val;");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic static explicit operator " + QualifiedName + " (GLib.Value val)");
+			sw.WriteLine ("\t\tpublic static explicit operator " + QualifiedName + " (Gst.GLib.Value val)");
 			sw.WriteLine ("\t\t{");
 
 			sw.WriteLine ("\t\t\treturn (" + QualifiedName + ") val.Val;");
diff -Naur generator-upstream/ByRefGen.cs generator/ByRefGen.cs
--- generator-upstream/ByRefGen.cs	2008-02-26 17:29:14.000000000 +0100
+++ generator/ByRefGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -46,7 +46,7 @@
 
 		public string AllocNative (string var_name)
 		{
-			return "GLib.Marshaller.StructureToPtrAlloc (" + var_name + ")";
+			return "Gst.GLib.Marshaller.StructureToPtrAlloc (" + var_name + ")";
 		}
 
 		public override string FromNative (string var_name)
diff -Naur generator-upstream/CallbackGen.cs generator/CallbackGen.cs
--- generator-upstream/CallbackGen.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/CallbackGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -140,7 +140,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\t" + Name + "Native native_cb;");
 			sw.WriteLine ("\t\tIntPtr __data;");
-			sw.WriteLine ("\t\tGLib.DestroyNotify __notify;");
+			sw.WriteLine ("\t\tGst.GLib.DestroyNotify __notify;");
 			sw.WriteLine ();
 			sw.WriteLine ("\t\t~" + Name + "Invoker ()");
 			sw.WriteLine ("\t\t{");
@@ -153,7 +153,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data) : this (native_cb, data, null) {}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data, GLib.DestroyNotify notify)");
+			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data, Gst.GLib.DestroyNotify notify)");
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tthis.native_cb = native_cb;");
 			sw.WriteLine ("\t\t\t__data = data;");
@@ -233,7 +233,7 @@
 			*/
 			bool fatal = (retval.MarshalType != "void" && retval.MarshalType != "bool") || call.HasOutParam;
 			sw.WriteLine ("\t\t\t} catch (Exception e) {");
-			sw.WriteLine ("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
+			sw.WriteLine ("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
 			if (fatal) {
 				sw.WriteLine ("\t\t\t\t// NOTREACHED: Above call does not return.");
 				sw.WriteLine ("\t\t\t\tthrow e;");
diff -Naur generator-upstream/ConstFilenameGen.cs generator/ConstFilenameGen.cs
--- generator-upstream/ConstFilenameGen.cs	2007-09-21 18:37:04.000000000 +0200
+++ generator/ConstFilenameGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -35,17 +35,17 @@
 		
 		public override string FromNative (string var)
 		{
-			return "GLib.Marshaller.FilenamePtrToString (" + var + ")";
+			return "Gst.GLib.Marshaller.FilenamePtrToString (" + var + ")";
 		}
 
 		public string AllocNative (string managed_var)
 		{
-			return "GLib.Marshaller.StringToFilenamePtr (" + managed_var + ")";
+			return "Gst.GLib.Marshaller.StringToFilenamePtr (" + managed_var + ")";
 		}
 
 		public string ReleaseNative (string native_var)
 		{
-			return "GLib.Marshaller.Free (" + native_var + ")";
+			return "Gst.GLib.Marshaller.Free (" + native_var + ")";
 		}
 	}
 }
diff -Naur generator-upstream/ConstStringGen.cs generator/ConstStringGen.cs
--- generator-upstream/ConstStringGen.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/ConstStringGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -37,17 +37,17 @@
 		
 		public override string FromNative (string var)
 		{
-			return "GLib.Marshaller.Utf8PtrToString (" + var + ")";
+			return "Gst.GLib.Marshaller.Utf8PtrToString (" + var + ")";
 		}
 
 		public string AllocNative (string managed_var)
 		{
-			return "GLib.Marshaller.StringToPtrGStrdup (" + managed_var + ")";
+			return "Gst.GLib.Marshaller.StringToPtrGStrdup (" + managed_var + ")";
 		}
 
 		public string ReleaseNative (string native_var)
 		{
-			return "GLib.Marshaller.Free (" + native_var + ")";
+			return "Gst.GLib.Marshaller.Free (" + native_var + ")";
 		}
 	}
 }
diff -Naur generator-upstream/Ctor.cs generator/Ctor.cs
--- generator-upstream/Ctor.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/Ctor.cs	2009-09-11 08:32:04.000000000 +0200
@@ -32,14 +32,16 @@
 		private bool preferred;
 		private string name;
 		private bool needs_chaining = false;
+		private bool mini_object = false;
 
 		public Ctor (XmlElement elem, ClassBase implementor) : base (elem, implementor) 
 		{
 			if (elem.HasAttribute ("preferred"))
 				preferred = true;
-			if (implementor is ObjectGen)
+			if (implementor is ObjectGen || implementor is MiniObjectGen)
 				needs_chaining = true;
 			name = implementor.Name;
+			mini_object = implementor is MiniObjectGen;
 		}
 
 		public bool Preferred {
@@ -110,9 +112,14 @@
 					sw.WriteLine ("\t\t\tif (GetType () != typeof (" + name + ")) {");
 					
 					if (Parameters.Count == 0) {
-						sw.WriteLine ("\t\t\t\tCreateNativeObject (new string [0], new GLib.Value[0]);");
+						if (mini_object)
+						  sw.WriteLine ("\t\t\t\tCreateNativeObject ();");
+						else
+						  sw.WriteLine ("\t\t\t\tCreateNativeObject (new string [0], new Gst.GLib.Value[0]);");
 						sw.WriteLine ("\t\t\t\treturn;");
 					} else {
+						if (mini_object)
+							throw new Exception ("MiniObject subclasses can't have ctors with parameters");
 						ArrayList names = new ArrayList ();
 						ArrayList values = new ArrayList ();
 						for (int i = 0; i < Parameters.Count; i++) {
@@ -137,13 +144,13 @@
 									indent += "\t";
 								}
 								sw.WriteLine (indent + "names.Add (\"" + names [i] + "\");");
-								sw.WriteLine (indent + "vals.Add (new GLib.Value (" + values[i] + "));");
+								sw.WriteLine (indent + "vals.Add (new Gst.GLib.Value (" + values[i] + "));");
 
 								if (p.Generatable is ClassBase && !(p.Generatable is StructBase))
 									sw.WriteLine ("\t\t\t\t}");
 							}
 
-							sw.WriteLine ("\t\t\t\tCreateNativeObject ((string[])names.ToArray (typeof (string)), (GLib.Value[])vals.ToArray (typeof (GLib.Value)));");
+							sw.WriteLine ("\t\t\t\tCreateNativeObject ((string[])names.ToArray (typeof (string)), (Gst.GLib.Value[])vals.ToArray (typeof (Gst.GLib.Value)));");
 							sw.WriteLine ("\t\t\t\treturn;");
 						} else
 							sw.WriteLine ("\t\t\t\tthrow new InvalidOperationException (\"Can't override this constructor.\");");
diff -Naur generator-upstream/DefaultSignalHandler.cs generator/DefaultSignalHandler.cs
--- generator-upstream/DefaultSignalHandler.cs	2009-04-13 19:44:48.000000000 +0200
+++ generator/DefaultSignalHandler.cs	2009-09-11 08:32:04.000000000 +0200
@@ -68,13 +68,13 @@
 		{
 			GenerateMethodBody (sw, implementor);
 			if (retval.IsVoid)
-				sw.WriteLine ("\t\t\tGLib.Value ret = GLib.Value.Empty;");
+				sw.WriteLine ("\t\t\tGst.GLib.Value ret = Gst.GLib.Value.Empty;");
 			else
-				sw.WriteLine ("\t\t\tGLib.Value ret = new GLib.Value (" + ReturnGType + ");");
+				sw.WriteLine ("\t\t\tGst.GLib.Value ret = new Gst.GLib.Value (" + ReturnGType + ");");
 
-			sw.WriteLine ("\t\t\tGLib.ValueArray inst_and_params = new GLib.ValueArray (" + (parms.Count + 1) + ");");
-			sw.WriteLine ("\t\t\tGLib.Value[] vals = new GLib.Value [" + (parms.Count + 1) + "];");
-			sw.WriteLine ("\t\t\tvals [0] = new GLib.Value (this);");
+			sw.WriteLine ("\t\t\tGst.GLib.ValueArray inst_and_params = new Gst.GLib.ValueArray (" + (parms.Count + 1) + ");");
+			sw.WriteLine ("\t\t\tGst.GLib.Value[] vals = new Gst.GLib.Value [" + (parms.Count + 1) + "];");
+			sw.WriteLine ("\t\t\tvals [0] = new Gst.GLib.Value (this);");
 			sw.WriteLine ("\t\t\tinst_and_params.Append (vals [0]);");
 			string cleanup = "";
 			for (int i = 0; i < parms.Count; i++) {
@@ -82,24 +82,24 @@
 				if (p.PassAs != "") {
 					if (SymbolTable.Table.IsBoxed (p.CType)) {
 						if (p.PassAs == "ref")
-							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + ");");
+							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + ");");
 						else
-							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value ((GLib.GType)typeof (" + p.CSType + "));");
+							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value ((Gst.GLib.GType)typeof (" + p.CSType + "));");
 						cleanup += "\t\t\t" + p.Name + " = (" + p.CSType + ") vals [" + i + "];\n";
 					} else {
 						if (p.PassAs == "ref")
-							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = GLib.Marshaller.StructureToPtrAlloc (" + p.Generatable.CallByName (p.Name) + ");");
+							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = Gst.GLib.Marshaller.StructureToPtrAlloc (" + p.Generatable.CallByName (p.Name) + ");");
 						else
 							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = Marshal.AllocHGlobal (Marshal.SizeOf (typeof (" + p.MarshalType + ")));");
 
-						sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + "_ptr);");
+						sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + "_ptr);");
 						cleanup += "\t\t\t" + p.Name + " = " + p.FromNative ("(" + p.MarshalType + ") Marshal.PtrToStructure (" + p.Name + "_ptr, typeof (" + p.MarshalType + "))") + ";\n";
 						cleanup += "\t\t\tMarshal.FreeHGlobal (" + p.Name + "_ptr);\n";
 					}
 				} else if (p.IsLength && i > 0 && parms [i - 1].IsString)
-					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (System.Text.Encoding.UTF8.GetByteCount (" + parms [i-1].Name + "));");
+					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (System.Text.Encoding.UTF8.GetByteCount (" + parms [i-1].Name + "));");
 				else
-					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + ");");
+					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + ");");
 
 				sw.WriteLine ("\t\t\tinst_and_params.Append (vals [" + (i + 1) + "]);");
 			}
@@ -107,7 +107,7 @@
 			sw.WriteLine ("\t\t\tg_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);");
 			if (cleanup != "")
 				sw.WriteLine (cleanup);
-			sw.WriteLine ("\t\t\tforeach (GLib.Value v in vals)");
+			sw.WriteLine ("\t\t\tforeach (Gst.GLib.Value v in vals)");
 			sw.WriteLine ("\t\t\t\tv.Dispose ();");
 			if (!retval.IsVoid) {
 				IGeneratable igen = SymbolTable.Table [retval.CType];
@@ -123,7 +123,9 @@
 				IGeneratable igen = SymbolTable.Table [retval.CType];
 
 				if (igen is ObjectGen)
-					return "GLib.GType.Object";
+					return "Gst.GLib.GType.Object";
+				if (igen is MiniObjectGen)
+					return "Gst.MiniObject.GType";
 				if (igen is BoxedGen)
 					return retval.CSType + ".GType";
 				if (igen is EnumGen)
@@ -131,11 +133,11 @@
 
 				switch (retval.CSType) {
 				case "bool":
-					return "GLib.GType.Boolean";
+					return "Gst.GLib.GType.Boolean";
 				case "string":
-					return "GLib.GType.String";
+					return "Gst.GLib.GType.String";
 				case "int":
-					return "GLib.GType.Int";
+					return "Gst.GLib.GType.Int";
 				default:
 					throw new Exception (retval.CSType);
 				}
diff -Naur generator-upstream/EnumGen.cs generator/EnumGen.cs
--- generator-upstream/EnumGen.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/EnumGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -98,7 +98,7 @@
 			if (Elem.GetAttribute("type") == "flags")
 				sw.WriteLine ("\t[Flags]");
 			if (Elem.HasAttribute("gtype"))
-				sw.WriteLine ("\t[GLib.GType (typeof (" + NS + "." + Name + "GType))]");
+				sw.WriteLine ("\t[Gst.GLib.GType (typeof (" + NS + "." + Name + "GType))]");
 
 			string access = IsInternal ? "internal" : "public";
 			sw.WriteLine ("\t" + access + " enum " + Name + enum_type + " {");
@@ -115,9 +115,9 @@
 				sw.WriteLine ("\t\t[DllImport (\"" + LibraryName + "\", CallingConvention = CallingConvention.Cdecl)]");
 				sw.WriteLine ("\t\tstatic extern IntPtr " + Elem.GetAttribute ("gtype") + " ();");
 				sw.WriteLine ();
-				sw.WriteLine ("\t\tpublic static GLib.GType GType {");
+				sw.WriteLine ("\t\tpublic static Gst.GLib.GType GType {");
 				sw.WriteLine ("\t\t\tget {");
-				sw.WriteLine ("\t\t\t\treturn new GLib.GType (" + Elem.GetAttribute ("gtype") + " ());");
+				sw.WriteLine ("\t\t\t\treturn new Gst.GLib.GType (" + Elem.GetAttribute ("gtype") + " ());");
 				sw.WriteLine ("\t\t\t}");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ("\t}");
diff -Naur generator-upstream/FieldBase.cs generator/FieldBase.cs
--- generator-upstream/FieldBase.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/FieldBase.cs	2009-09-11 08:32:04.000000000 +0200
@@ -89,7 +89,7 @@
 		void CheckGlue ()
 		{
 			getterName = setterName = getOffsetName = null;
-			if (Access != "public")
+			if (DefaultAccess != "public" && (!elem.HasAttribute ("access") || (Access != "public" && Access != "protected" && Access != "internal")))
 				return;
 
 			string prefix = (container_type.NS + "Sharp_" + container_type.NS + "_" + container_type.Name).Replace(".", "__").ToLower ();
@@ -154,8 +154,9 @@
 			StreamWriter sw = gen_info.Writer;
 			string modifiers = elem.HasAttribute ("new_flag") ? "new " : "";
 			bool is_struct = table.IsStruct (CType) || table.IsBoxed (CType);
+			string access = elem.HasAttribute ("access") ? elem.GetAttribute ("access") : "public";
 
-			sw.WriteLine (indent + "public " + modifiers + CSType + " " + Name + " {");
+			sw.WriteLine (indent + access + " " + modifiers + CSType + " " + Name + " {");
 
 			if (Getter != null) {
 				sw.Write (indent + "\tget ");
diff -Naur generator-upstream/gapi3-codegen.in generator/gapi3-codegen.in
diff -Naur generator-upstream/GObjectVM.cs generator/GObjectVM.cs
--- generator-upstream/GObjectVM.cs	2009-08-09 01:42:15.000000000 +0200
+++ generator/GObjectVM.cs	2009-09-11 08:32:04.000000000 +0200
@@ -154,17 +154,17 @@
 				sw.WriteLine ("\t\tpublic static " + Name + "Delegate " + Name + "Handler {");
 				sw.WriteLine ("\t\t\tset {");
 				sw.WriteLine ("\t\t\t\t{0}_handler = value;", CName);
-				sw.WriteLine ("\t\t\t\tOverride{0} ((GLib.GType) typeof ({1}), value == null ? null : {0}VMCallback);", Name, container_type.Name);
+				sw.WriteLine ("\t\t\t\tOverride{0} ((Gst.GLib.GType) typeof ({1}), value == null ? null : {0}VMCallback);", Name, container_type.Name);
 				sw.WriteLine ("\t\t\t}");
 				sw.WriteLine ("\t\t}");
 			} else {
-				sw.WriteLine ("\t\tstatic void Override{0} (GLib.GType gtype)", this.Name);
+				sw.WriteLine ("\t\tstatic void Override{0} (Gst.GLib.GType gtype)", this.Name);
 				sw.WriteLine ("\t\t{");
 				sw.WriteLine ("\t\t\tOverride{0} (gtype, {0}VMCallback);", this.Name);
 				sw.WriteLine ("\t\t}");
 			}
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic void Override{0} (GLib.GType gtype, {0}NativeDelegate callback)", this.Name);
+			sw.WriteLine ("\t\tstatic void Override{0} (Gst.GLib.GType gtype, {0}NativeDelegate callback)", this.Name);
 			sw.WriteLine ("\t\t{");
 		}
 
@@ -181,7 +181,7 @@
 
 		protected void GenerateMethodBody (StreamWriter sw, ClassBase implementor)
 		{
-			sw.WriteLine ("\t\t[GLib.DefaultSignalHandler(Type=typeof(" + (implementor != null ? implementor.QualifiedName : container_type.QualifiedName) + "), ConnectionMethod=\"Override" + this.Name +"\")]");
+			sw.WriteLine ("\t\t[Gst.GLib.DefaultSignalHandler(Type=typeof(" + (implementor != null ? implementor.QualifiedName : container_type.QualifiedName) + "), ConnectionMethod=\"Override" + this.Name +"\")]");
 			sw.Write ("\t\t{0} ", this.Protection);
 			if (this.modifiers != "")
 				sw.Write ("{0} ", this.modifiers);
@@ -261,7 +261,7 @@
 					return "FALSE";
 				case "true":
 					return "TRUE";
-				case "GLib.GType.None":
+				case "Gst.GLib.GType.None":
 					return "G_TYPE_NONE";
 				default:
 					return val;
diff -Naur generator-upstream/gst-gapi_codegen.exe generator/gst-gapi_codegen.exe
diff -Naur generator-upstream/gst-gapi_codegen.exe.mdb generator/gst-gapi_codegen.exe.mdb
diff -Naur generator-upstream/InterfaceGen.cs generator/InterfaceGen.cs
--- generator-upstream/InterfaceGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/InterfaceGen.cs	2009-09-11 08:32:04.000000000 +0200
@@ -60,7 +60,7 @@
 
 		public override string CallByName (string var, bool owned)
 		{
-			return String.Format ("{0} == null ? IntPtr.Zero : (({0} is GLib.Object) ? ({0} as GLib.Object).{1} : ({0} as {2}Adapter).{1})", var, owned ? "OwnedHandle" : "Handle", QualifiedName);
+			return String.Format ("{0} == null ? IntPtr.Zero : (({0} is Gst.GLib.Object) ? ({0} as Gst.GLib.Object).{1} : ({0} as {2}Adapter).{1})", var, owned ? "OwnedHandle" : "Handle", QualifiedName);
 		}
 
 		public override string FromNative (string var, bool owned)
@@ -91,7 +91,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\tstatic " + Name + "Adapter ()");
 			sw.WriteLine ("\t\t{");
-			sw.WriteLine ("\t\t\tGLib.GType.Register (_gtype, typeof({0}Adapter));", Name);
+			sw.WriteLine ("\t\t\tGst.GLib.GType.Register (_gtype, typeof({0}Adapter));", Name);
 			foreach (InterfaceVM vm in interface_vms) {
 				if (vm.IsValid)
 					sw.WriteLine ("\t\t\tiface.{0} = new {0}NativeDelegate ({0}_cb);", vm.Name);
@@ -127,22 +127,22 @@
 		void GenerateCtors (StreamWriter sw)
 		{
 			// Native GObjects do not implement the *Implementor interfaces
-			sw.WriteLine ("\t\tGLib.Object implementor;", Name);
+			sw.WriteLine ("\t\tGst.GLib.Object implementor;", Name);
 			sw.WriteLine ();
 
 			if (!IsConsumeOnly) {
 				sw.WriteLine ("\t\tpublic " + Name + "Adapter ()");
 				sw.WriteLine ("\t\t{");
-				sw.WriteLine ("\t\t\tInitHandler = new GLib.GInterfaceInitHandler (Initialize);");
+				sw.WriteLine ("\t\t\tInitHandler = new Gst.GLib.GInterfaceInitHandler (Initialize);");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 				sw.WriteLine ("\t\tpublic {0}Adapter ({0}Implementor implementor)", Name);
 				sw.WriteLine ("\t\t{");
 				sw.WriteLine ("\t\t\tif (implementor == null)");
 				sw.WriteLine ("\t\t\t\tthrow new ArgumentNullException (\"implementor\");");
-				sw.WriteLine ("\t\t\telse if (!(implementor is GLib.Object))");
-				sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"implementor must be a subclass of GLib.Object\");");
-				sw.WriteLine ("\t\t\tthis.implementor = implementor as GLib.Object;");
+				sw.WriteLine ("\t\t\telse if (!(implementor is Gst.GLib.Object))");
+				sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"implementor must be a subclass of Gst.GLib.Object\");");
+				sw.WriteLine ("\t\t\tthis.implementor = implementor as Gst.GLib.Object;");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 			}
@@ -151,7 +151,7 @@
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (!_gtype.IsInstance (handle))");
 			sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"The gobject doesn't implement the GInterface of this adapter\", \"handle\");");
-			sw.WriteLine ("\t\t\timplementor = GLib.Object.GetObject (handle);");
+			sw.WriteLine ("\t\t\timplementor = Gst.GLib.Object.GetObject (handle);");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
 		}
@@ -160,9 +160,9 @@
 		{
 			Method m = GetMethod ("GetType");
 			m.GenerateImport (sw);
-			sw.WriteLine ("\t\tprivate static GLib.GType _gtype = new GLib.GType ({0} ());", m.CName);
+			sw.WriteLine ("\t\tprivate static Gst.GLib.GType _gtype = new Gst.GLib.GType ({0} ());", m.CName);
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic override GLib.GType GType {");
+			sw.WriteLine ("\t\tpublic override Gst.GLib.GType GType {");
 			sw.WriteLine ("\t\t\tget {");
 			sw.WriteLine ("\t\t\t\treturn _gtype;");
 			sw.WriteLine ("\t\t\t}");
@@ -190,11 +190,11 @@
 		{
 			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (IntPtr handle, bool owned)");
 			sw.WriteLine ("\t\t{");
-			sw.WriteLine ("\t\t\tGLib.Object obj = GLib.Object.GetObject (handle, owned);");
+			sw.WriteLine ("\t\t\tGst.GLib.Object obj = Gst.GLib.Object.GetObject (handle, owned);");
 			sw.WriteLine ("\t\t\treturn GetObject (obj);");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (GLib.Object obj)");
+			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (Gst.GLib.Object obj)");
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (obj == null)");
 			sw.WriteLine ("\t\t\t\treturn null;");
@@ -230,7 +230,7 @@
 			sw.WriteLine ("\tusing System.Runtime.InteropServices;");
 			sw.WriteLine ();
 			sw.WriteLine ("#region Autogenerated code");
-			sw.WriteLine ("\tpublic partial class " + Name + "Adapter : GLib.GInterfaceAdapter, " + QualifiedName + " {");
+			sw.WriteLine ("\tpublic partial class " + Name + "Adapter : Gst.GLib.GInterfaceAdapter, " + QualifiedName + " {");
 			sw.WriteLine ();
 
 			if (!IsConsumeOnly) {
@@ -249,7 +249,7 @@
 			GenProperties (gen_info, null);
 
 			foreach (Signal sig in sigs.Values)
-				sig.GenEvent (sw, null, "GLib.Object.GetObject (Handle)");
+				sig.GenEvent (sw, null, "Gst.GLib.Object.GetObject (Handle)");
 
 			Method temp = methods ["GetType"] as Method;
 			if (temp != null)
@@ -275,9 +275,9 @@
 				return;
 
 			sw.WriteLine ();
-			sw.WriteLine ("\t[GLib.GInterface (typeof (" + Name + "Adapter))]");
+			sw.WriteLine ("\t[Gst.GLib.GInterface (typeof (" + Name + "Adapter))]");
 			string access = IsInternal ? "internal" : "public";
-			sw.WriteLine ("\t" + access + " partial interface " + Name + "Implementor : GLib.IWrapper {");
+			sw.WriteLine ("\t" + access + " partial interface " + Name + "Implementor : Gst.GLib.IWrapper {");
 			sw.WriteLine ();
 			Hashtable vm_table = new Hashtable ();
 			foreach (InterfaceVM vm in interface_vms) {
@@ -323,7 +323,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("#region Autogenerated code");
 			string access = IsInternal ? "internal" : "public";
-			sw.WriteLine ("\t" + access + " partial interface " + Name + " : GLib.IWrapper {");
+			sw.WriteLine ("\t" + access + " partial interface " + Name + " : Gst.GLib.IWrapper {");
 			sw.WriteLine ();
 			
 			foreach (Signal sig in sigs.Values) {
diff -Naur generator-upstream/Makefile generator/Makefile
--- generator-upstream/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ generator/Makefile	2009-09-11 07:59:21.000000000 +0200
@@ -0,0 +1,456 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# generator/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+pkgdatadir = $(datadir)/gstreamer-sharp
+pkgincludedir = $(includedir)/gstreamer-sharp
+pkglibdir = $(libdir)/gstreamer-sharp
+pkglibexecdir = $(libexecdir)/gstreamer-sharp
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = x86_64-unknown-linux-gnu
+host_triplet = x86_64-unknown-linux-gnu
+target_triplet = x86_64-unknown-linux-gnu
+subdir = generator
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SCRIPTS = $(noinst_SCRIPTS)
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run aclocal-1.11
+AMTAR = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run automake-1.11
+AWK = gawk
+CC = gcc-4.4
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = cpp-4.4
+CPPFLAGS = 
+CSC = /usr/bin/gmcs
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+GACUTIL = /usr/bin/gacutil
+GACUTIL_FLAGS = /package $(PACKAGE_VERSION) /gacdir $(libdir) /root $(DESTDIR)/$(libdir)
+GENERATED_SOURCES = generated/*.cs
+GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+GLIB_LIBS = -lgobject-2.0 -lglib-2.0  
+GLIB_SHARP_CFLAGS = -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/glib-api.xml  
+GLIB_SHARP_LIBS = -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glib-sharp.dll  
+GREP = /bin/grep
+GSTREAMER_PLUGINS_REQUIRED_VERSION = 0.10.24
+GSTREAMER_REQUIRED_VERSION = 0.10.24
+GST_CFLAGS = -pthread -I/home/slomo/projects/gstreamer/head/gstreamer/pkgconfig/.. -I./.. -I/home/slomo/projects/gstreamer/head/gstreamer/pkgconfig/../libs -I./../libs -I/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs -I./../gst-libs -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include -I/usr/include/libxml2  
+GST_LIBS = /home/slomo/projects/gstreamer/head/gstreamer/pkgconfig/../gst/libgstreamer-0.10.la /home/slomo/projects/gstreamer/head/gstreamer/pkgconfig/../libs/gst/base/libgstbase-0.10.la /home/slomo/projects/gstreamer/head/gstreamer/pkgconfig/../libs/gst/controller/libgstcontroller-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/app/libgstapp-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/audio/libgstaudio-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/interfaces/libgstinterfaces-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/cdda/libgstcdda-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/tag/libgsttag-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/pbutils/libgstpbutils-0.10.la /home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/video/libgstvideo-0.10.la -pthread -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/app -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/audio -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/interfaces -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/cdda -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/tag -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/pbutils -L/home/slomo/projects/gstreamer/head/gst-plugins-base/pkgconfig/../gst-libs/gst/video -lgobject-2.0 -lgmodule-2.0 -lgthread-2.0 -lrt -lxml2 -lglib-2.0  
+GTK_SHARP_CFLAGS = -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/pango-api.xml -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/atk-api.xml -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/gdk-api.xml -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/gtk-api.xml -I:/usr/local/lib/pkgconfig/../../share/gapi-2.0/glib-api.xml  
+GTK_SHARP_LIBS = -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/pango-sharp.dll -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/atk-sharp.dll -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gdk-sharp.dll -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gtk-sharp.dll -r:/usr/local/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glib-sharp.dll  
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/bin/ld -m elf_x86_64
+LDFLAGS = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIB_PREFIX = .so
+LIB_SUFFIX = 
+LIPO = 
+LN_S = ln -s
+LTLIBOBJS = 
+MAINT = 
+MAKEINFO = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/missing --run makeinfo
+MDASSEMBLER = /usr/bin/mdassembler
+MKDIR_P = /bin/mkdir -p
+MONO = /usr/bin/mono
+MONODOCER = /usr/bin/monodocer
+MONODOCS2HTML = /usr/bin/monodocs2html
+MONODOC_DEPENDENCY_CFLAGS =  
+MONODOC_DEPENDENCY_LIBS = /r:/usr/lib/mono/monodoc/monodoc.dll  
+MONODOC_REQUIRED_VERSION = 1.1
+MONO_CAIRO_CFLAGS =  
+MONO_CAIRO_LIBS = -r:/usr/lib/mono/2.0/Mono.Cairo.dll  
+MONO_DEPENDENCY_CFLAGS = -D_REENTRANT -pthread -I/usr/include/mono-1.0 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+MONO_DEPENDENCY_LIBS = -Wl,--export-dynamic -pthread -lmono -ldl -lpthread -lm -lgthread-2.0 -lrt -lglib-2.0  
+MONO_NUNIT_CFLAGS =  
+MONO_NUNIT_LIBS = -r:/usr/lib/cli/nunit-2.4/nunit.core.dll -r:/usr/lib/cli/nunit-2.4/nunit.util.dll -r:/usr/lib/cli/nunit-2.4/nunit.framework.dll -r:/usr/lib/cli/nunit-2.4/nunit.core.interfaces.dll  
+MONO_REQUIRED_VERSION = 2.4
+NM = /usr/bin/nm -B
+NMEDIT = 
+NUNIT_TESTER = /usr/bin/nunit-console
+OBJDUMP = objdump
+OBJEXT = o
+OFF_T_FLAGS = -define:OFF_T_8
+OTOOL = 
+OTOOL64 = 
+PACKAGE = gstreamer-sharp
+PACKAGE_BUGREPORT = http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer&component=gst-sharp
+PACKAGE_NAME = gstreamer-sharp
+PACKAGE_STRING = gstreamer-sharp 0.9.0
+PACKAGE_TARNAME = gstreamer-sharp
+PACKAGE_URL = 
+PACKAGE_VERSION = gstreamer-sharp-0.10
+PATH_SEPARATOR = :
+PKG_CONFIG = /usr/bin/pkg-config
+RANLIB = ranlib
+RUNTIME = 
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 0.9.0
+abs_builddir = /home/slomo/projects/gstreamer/head/gstreamer-sharp/generator
+abs_srcdir = /home/slomo/projects/gstreamer/head/gstreamer-sharp/generator
+abs_top_builddir = /home/slomo/projects/gstreamer/head/gstreamer-sharp
+abs_top_srcdir = /home/slomo/projects/gstreamer/head/gstreamer-sharp
+ac_ct_CC = gcc-4.4
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = x86_64-unknown-linux-gnu
+build_alias = 
+build_cpu = x86_64
+build_os = linux-gnu
+build_vendor = unknown
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = x86_64-unknown-linux-gnu
+host_alias = 
+host_cpu = x86_64
+host_os = linux-gnu
+host_vendor = unknown
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /home/slomo/projects/gstreamer/head/gstreamer-sharp/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+lt_ECHO = echo
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target = x86_64-unknown-linux-gnu
+target_alias = 
+target_cpu = x86_64
+target_os = linux-gnu
+target_vendor = unknown
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+noinst_SCRIPTS = gst-gapi_codegen.exe
+references = 
+sources = \
+	AliasGen.cs			\
+	BoxedGen.cs			\
+	ByRefGen.cs			\
+	CallbackGen.cs			\
+	ChildProperty.cs		\
+	ClassBase.cs			\
+	ClassField.cs			\
+	ClassGen.cs			\
+	CodeGenerator.cs		\
+	ConstFilenameGen.cs		\
+	ConstStringGen.cs		\
+	Ctor.cs				\
+	DefaultSignalHandler.cs		\
+	EnumGen.cs			\
+	FieldBase.cs			\
+	GenBase.cs			\
+	GenerationInfo.cs		\
+	GObjectVM.cs			\
+	HandleBase.cs			\
+	IAccessor.cs			\
+	IGeneratable.cs			\
+	IManualMarshaler.cs		\
+	InterfaceGen.cs			\
+	InterfaceVM.cs			\
+	LPGen.cs			\
+	LPUGen.cs			\
+	ManagedCallString.cs		\
+	ManualGen.cs			\
+	MarshalGen.cs			\
+	MethodBase.cs			\
+	MethodBody.cs			\
+	Method.cs			\
+	MiniObjectGen.cs		\
+	ObjectField.cs			\
+	ObjectBase.cs			\
+	ObjectGen.cs			\
+	OpaqueGen.cs			\
+	Parameters.cs			\
+	Parser.cs			\
+	Property.cs			\
+	PropertyBase.cs			\
+	ReturnValue.cs			\
+	Signal.cs			\
+	Signature.cs			\
+	SimpleBase.cs			\
+	SimpleGen.cs			\
+	Statistics.cs			\
+	StructBase.cs			\
+	StructField.cs			\
+	StructGen.cs			\
+	SymbolTable.cs			\
+	VirtualMethod.cs		\
+	VMSignature.cs
+
+build_sources = $(addprefix $(srcdir)/, $(sources))
+dist_sources = $(sources)
+EXTRA_DIST = \
+	$(dist_sources)
+
+CLEANFILES = gst-gapi_codegen.exe gst-gapi_codegen.exe.mdb
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign generator/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign generator/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(SCRIPTS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am
+
+
+gst-gapi_codegen.exe: $(build_sources)
+	$(CSC) -debug -out:gst-gapi_codegen.exe $(OFF_T_FLAGS) $(references) $(build_sources)
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur generator-upstream/Makefile.am generator/Makefile.am
diff -Naur generator-upstream/Makefile.in generator/Makefile.in
diff -Naur generator-upstream/MethodBody.cs generator/MethodBody.cs
--- generator-upstream/MethodBody.cs	2009-01-07 18:10:08.000000000 +0100
+++ generator/MethodBody.cs	2009-09-11 08:32:04.000000000 +0200
@@ -111,7 +111,7 @@
 						sw.WriteLine (indent + "\t\t\t\t{0} = null;", parameters [i + 2].Name);
 						sw.WriteLine (indent + "\t\t\t} else {");
 						sw.WriteLine (indent + "\t\t\t\t{0} = (IntPtr) GCHandle.Alloc ({1}_wrapper);", parameters [i + 1].Name, name);
-						sw.WriteLine (indent + "\t\t\t\t{0} = GLib.DestroyHelper.NotifyHandler;", parameters [i + 2].Name, parameters [i + 2].CSType);
+						sw.WriteLine (indent + "\t\t\t\t{0} = Gst.GLib.DestroyHelper.NotifyHandler;", parameters [i + 2].Name, parameters [i + 2].CSType);
 						sw.WriteLine (indent + "\t\t\t}");
 						break;
 
@@ -154,7 +154,7 @@
 		{
 			if (!ThrowsException)
 				return;
-			sw.WriteLine (indent + "\t\t\tif (error != IntPtr.Zero) throw new GLib.GException (error);");
+			sw.WriteLine (indent + "\t\t\tif (error != IntPtr.Zero) throw new Gst.GLib.GException (error);");
 		}
 		
 		public bool ThrowsException {
diff -Naur generator-upstream/Method.cs generator/Method.cs
--- generator-upstream/Method.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/Method.cs	2009-09-11 08:32:04.000000000 +0200
@@ -118,7 +118,7 @@
 
 			if (Name == "ToString" && Parameters.Count == 0)
 				sw.Write("override ");
-			else if (Name == "GetGType" && container_type is ObjectGen)
+			else if (Name == "GetGType" && (container_type is ObjectGen || container_type is MiniObjectGen))
 				sw.Write("new ");
 			else if (Modifiers == "new " || (dup != null && ((dup.Signature != null && Signature != null && dup.Signature.ToString() == Signature.ToString()) || (dup.Signature == null && Signature == null))))
 				sw.Write("new ");
diff -Naur generator-upstream/MiniObjectGen.cs generator/MiniObjectGen.cs
--- generator-upstream/MiniObjectGen.cs	1970-01-01 01:00:00.000000000 +0100
+++ generator/MiniObjectGen.cs	2009-09-03 11:03:48.000000000 +0200
@@ -0,0 +1,326 @@
+// GtkSharp.Generation.MiniObjectGen.cs - The Mini Object Generatable.
+//
+// Author: Mike Kestner <mkestner@ximian.com>
+//
+// Copyright (c) 2001-2003 Mike Kestner
+// Copyright (c) 2003-2004 Novell, Inc.
+// Copyright (c) 2009 Sebastian Dröge <sebastian.droege@collabora.co.uk>.
+//
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of version 2 of the GNU General Public
+// License as published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// General Public License for more details.
+//
+// You should have received a copy of the GNU General Public
+// License along with this program; if not, write to the
+// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+
+namespace GtkSharp.Generation {
+
+	using System;
+	using System.Collections;
+	using System.IO;
+	using System.Text;
+	using System.Xml;
+
+	public class MiniObjectGen : ObjectBase  {
+
+		private ArrayList custom_attrs = new ArrayList();
+		private ArrayList strings = new ArrayList();
+		private static Hashtable dirs = new Hashtable ();
+
+		public MiniObjectGen (XmlElement ns, XmlElement elem) : base (ns, elem, false) 
+		{
+			foreach (XmlNode node in elem.ChildNodes) {
+				if (!(node is XmlElement)) continue;
+				XmlElement member = (XmlElement) node;
+				if (member.HasAttribute ("hidden") && member.GetAttribute ("hidden") == "1") continue;
+
+				switch (node.Name) {
+				case "custom-attribute":
+					custom_attrs.Add (member.InnerXml);
+					break;
+
+				case "static-string":
+					strings.Add (node);
+					break;
+
+				default:
+					if (!IsNodeNameHandled (node.Name))
+						Console.WriteLine ("Unexpected node " + node.Name + " in " + CName);
+					break;
+				}
+			}
+		}
+
+		public override string CallByName (string var, bool owned)
+		{
+			return String.Format ("{0} == null ? IntPtr.Zero : {0}.{1}", var, owned ? "OwnedHandle" : "Handle");
+		}
+
+		public override bool Validate ()
+		{
+			ArrayList invalids = new ArrayList ();
+
+			return base.Validate ();
+		}
+
+		private bool DisableVoidCtor {
+			get {
+				return Elem.HasAttribute ("disable_void_ctor");
+			}
+		}
+
+		private bool DisableGTypeCtor {
+			get {
+				return Elem.HasAttribute ("disable_gtype_ctor");
+			}
+		}
+
+		private class DirectoryInfo {
+			public string assembly_name;
+			public Hashtable objects;
+
+			public DirectoryInfo (string assembly_name) {
+				this.assembly_name = assembly_name;
+				objects = new Hashtable ();
+			}
+		}
+
+		private static DirectoryInfo GetDirectoryInfo (string dir, string assembly_name)
+		{
+			DirectoryInfo result;
+
+			if (dirs.ContainsKey (dir)) {
+				result = dirs [dir] as DirectoryInfo;
+				if  (result.assembly_name != assembly_name) {
+					Console.WriteLine ("Can't put multiple assemblies in one directory.");
+					return null;
+				}
+
+				return result;
+			}
+
+			result = new DirectoryInfo (assembly_name);
+			dirs.Add (dir, result);
+			
+			return result;
+		}
+
+		public override void Generate (GenerationInfo gen_info)
+		{
+			gen_info.CurrentType = Name;
+
+			string asm_name = gen_info.AssemblyName.Length == 0 ? NS.ToLower () + "-sharp" : gen_info.AssemblyName;
+			DirectoryInfo di = GetDirectoryInfo (gen_info.Dir, asm_name);
+
+			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
+
+			sw.WriteLine ("namespace " + NS + " {");
+			sw.WriteLine ();
+			sw.WriteLine ("\tusing System;");
+			sw.WriteLine ("\tusing System.Collections;");
+			sw.WriteLine ("\tusing System.Runtime.InteropServices;");
+			sw.WriteLine ();
+
+			SymbolTable table = SymbolTable.Table;
+
+			sw.WriteLine ("#region Autogenerated code");
+			if (IsDeprecated)
+				sw.WriteLine ("\t[Obsolete]");
+			foreach (string attr in custom_attrs)
+				sw.WriteLine ("\t" + attr);
+			sw.Write ("\t{0} {1}class " + Name, IsInternal ? "internal" : "public", IsAbstract ? "abstract " : "");
+			string cs_parent = table.GetCSType(Elem.GetAttribute("parent"));
+			if (cs_parent != "") {
+				di.objects.Add (CName, QualifiedName);
+				sw.Write (" : " + cs_parent);
+			}
+			foreach (string iface in managed_interfaces) {
+				if (Parent != null && Parent.Implements (iface))
+					continue;
+				sw.Write (", " + iface);
+			}
+			sw.WriteLine (" {");
+			sw.WriteLine ();
+
+			GenCtors (gen_info);
+			GenFields (gen_info);
+			
+			GenClassMembers (gen_info, cs_parent);
+			GenMethods (gen_info, null, null);
+			
+			foreach (XmlElement str in strings) {
+				sw.Write ("\t\tpublic static string " + str.GetAttribute ("name"));
+				sw.WriteLine (" {\n\t\t\t get { return \"" + str.GetAttribute ("value") + "\"; }\n\t\t}");
+			}
+
+			if (cs_parent != String.Empty && GetExpected (CName) != QualifiedName) {
+				sw.WriteLine ();
+				sw.WriteLine ("\t\tstatic " + Name + " ()");
+				sw.WriteLine ("\t\t{");
+				sw.WriteLine ("\t\t\tGtkSharp." + Studlify (asm_name) + ".ObjectManager.Initialize ();");
+				sw.WriteLine ("\t\t}");
+			}
+
+			sw.WriteLine ("#endregion");
+			AppendCustom (sw, gen_info.CustomDir);
+
+			sw.WriteLine ("\t}");
+			sw.WriteLine ("}");
+
+			sw.Close ();
+			gen_info.Writer = null;
+			Statistics.ObjectCount++;
+		}
+
+		protected override void GenCtors (GenerationInfo gen_info)
+		{
+			if (!Elem.HasAttribute("parent"))
+				return;
+
+			if (!DisableGTypeCtor) {
+				gen_info.Writer.WriteLine("\t\t[Obsolete]");
+				gen_info.Writer.WriteLine("\t\tprotected " + Name + "(Gst.GLib.GType gtype) : base(gtype) {}");
+			}
+			gen_info.Writer.WriteLine("\t\tpublic " + Name + "(IntPtr raw) : base(raw) {}");
+			if (ctors.Count == 0 && !DisableVoidCtor) {
+				gen_info.Writer.WriteLine();
+				gen_info.Writer.WriteLine("\t\tprotected " + Name + "() : base(IntPtr.Zero)");
+				gen_info.Writer.WriteLine("\t\t{");
+				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject ();");
+				gen_info.Writer.WriteLine("\t\t}");
+			}
+			gen_info.Writer.WriteLine();
+
+			base.GenCtors (gen_info);
+		}
+
+		void GenClassMembers (GenerationInfo gen_info, string cs_parent)
+		{
+			GenVirtualMethods (gen_info, null);
+
+			if (class_struct_name == null || !CanGenerateClassStruct) return;
+			StreamWriter sw = gen_info.Writer;
+			GenerateClassStruct (gen_info);
+			if (cs_parent == "")
+				sw.WriteLine ("\t\tstatic uint class_offset = 0;");
+			else
+				sw.WriteLine ("\t\tstatic uint class_offset = ((Gst.GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
+			sw.WriteLine ("\t\tstatic Hashtable class_structs;");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic {0} GetClassStruct (Gst.GLib.GType gtype, bool use_cache)", class_struct_name);
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tif (class_structs == null)");
+			sw.WriteLine ("\t\t\t\tclass_structs = new Hashtable ();");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\t\tif (use_cache && class_structs.Contains (gtype))");
+			sw.WriteLine ("\t\t\t\treturn ({0}) class_structs [gtype];", class_struct_name);
+			sw.WriteLine ("\t\t\telse {");
+			sw.WriteLine ("\t\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
+			sw.WriteLine ("\t\t\t\t{0} class_struct = ({0}) Marshal.PtrToStructure (class_ptr, typeof ({0}));", class_struct_name);
+			sw.WriteLine ("\t\t\t\tif (use_cache)");
+			sw.WriteLine ("\t\t\t\t\tclass_structs.Add (gtype, class_struct);");
+			sw.WriteLine ("\t\t\t\treturn class_struct;");
+			sw.WriteLine ("\t\t\t}");
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic void OverrideClassStruct (Gst.GLib.GType gtype, {0} class_struct)", class_struct_name);
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
+			sw.WriteLine ("\t\t\tMarshal.StructureToPtr (class_struct, class_ptr, false);");
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ();
+		}
+
+		/* Keep this in sync with the one in glib/GType.cs */
+		private static string GetExpected (string cname)
+		{
+			for (int i = 1; i < cname.Length; i++) {
+				if (Char.IsUpper (cname[i])) {
+					if (i == 1 && cname[0] == 'G')
+						return "Gst.GLib." + cname.Substring (1);
+					else
+						return cname.Substring (0, i) + "." + cname.Substring (i);
+				}
+			}
+
+			throw new ArgumentException ("cname doesn't follow the NamespaceType capitalization style: " + cname);
+		}
+
+		private static bool NeedsMap (Hashtable objs, string assembly_name)
+		{
+			foreach (string key in objs.Keys)
+				if (GetExpected (key) != ((string) objs[key]))
+					return true;
+			
+			return false;
+		}
+
+		private static string Studlify (string name)
+		{
+			string result = "";
+
+			string[] subs = name.Split ('-');
+			foreach (string sub in subs)
+				result += Char.ToUpper (sub[0]) + sub.Substring (1);
+				
+			return result;
+		}
+				
+		public static void GenerateMappers ()
+		{
+			foreach (string dir in dirs.Keys) {
+
+				DirectoryInfo di = dirs[dir] as DirectoryInfo;
+
+				if (!NeedsMap (di.objects, di.assembly_name))
+					continue;
+	
+				GenerationInfo gen_info = new GenerationInfo (dir, di.assembly_name);
+
+				GenerateMapper (di, gen_info);
+			}
+		}
+
+		private static void GenerateMapper (DirectoryInfo dir_info, GenerationInfo gen_info)
+		{
+			StreamWriter sw = gen_info.OpenStream ("ObjectManager");
+
+			sw.WriteLine ("namespace GtkSharp." + Studlify (dir_info.assembly_name) + " {");
+			sw.WriteLine ();
+			sw.WriteLine ("\tpublic class ObjectManager {");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic bool initialized = false;");
+			sw.WriteLine ("\t\t// Call this method from the appropriate module init function.");
+			sw.WriteLine ("\t\tpublic static void Initialize ()");
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tif (initialized)");
+			sw.WriteLine ("\t\t\t\treturn;");
+			sw.WriteLine ("");
+			sw.WriteLine ("\t\t\tinitialized = true;");
+	
+			foreach (string key in dir_info.objects.Keys) {
+				if (GetExpected(key) != ((string) dir_info.objects[key]))
+					sw.WriteLine ("\t\t\tGst.GLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
+			}
+					
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ("\t}");
+			sw.WriteLine ("}");
+			sw.Close ();
+		}
+
+		public override string FromNative (string var, bool owned)
+		{
+			return "Gst.MiniObject.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
+		}
+	}
+}
+
diff -Naur generator-upstream/ObjectBase.cs generator/ObjectBase.cs
--- generator-upstream/ObjectBase.cs	2009-08-05 08:24:27.000000000 +0200
+++ generator/ObjectBase.cs	2009-09-11 08:32:06.000000000 +0200
@@ -164,7 +164,7 @@
 
 		public override string FromNative (string var, bool owned)
 		{
-			return "GLib.Object.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
+			return "Gst.GLib.Object.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
 		}
 
 		public string ClassStructName {
diff -Naur generator-upstream/ObjectGen.cs generator/ObjectGen.cs
--- generator-upstream/ObjectGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/ObjectGen.cs	2009-09-11 08:32:06.000000000 +0200
@@ -253,7 +253,7 @@
 				gen_info.Writer.WriteLine();
 				gen_info.Writer.WriteLine("\t\tprotected " + Name + "() : base(IntPtr.Zero)");
 				gen_info.Writer.WriteLine("\t\t{");
-				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject (new string [0], new GLib.Value [0]);");
+				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject (new string [0], new Gst.GLib.Value [0]);");
 				gen_info.Writer.WriteLine("\t\t}");
 			}
 			gen_info.Writer.WriteLine();
@@ -302,10 +302,10 @@
 			if (cs_parent == "")
 				sw.WriteLine ("\t\tstatic uint class_offset = 0;");
 			else
-				sw.WriteLine ("\t\tstatic uint class_offset = ((GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
+				sw.WriteLine ("\t\tstatic uint class_offset = ((Gst.GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
 			sw.WriteLine ("\t\tstatic Hashtable class_structs;");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic {0} GetClassStruct (GLib.GType gtype, bool use_cache)", class_struct_name);
+			sw.WriteLine ("\t\tstatic {0} GetClassStruct (Gst.GLib.GType gtype, bool use_cache)", class_struct_name);
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (class_structs == null)");
 			sw.WriteLine ("\t\t\t\tclass_structs = new Hashtable ();");
@@ -321,7 +321,7 @@
 			sw.WriteLine ("\t\t\t}");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic void OverrideClassStruct (GLib.GType gtype, {0} class_struct)", class_struct_name);
+			sw.WriteLine ("\t\tstatic void OverrideClassStruct (Gst.GLib.GType gtype, {0} class_struct)", class_struct_name);
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
 			sw.WriteLine ("\t\t\tMarshal.StructureToPtr (class_struct, class_ptr, false);");
@@ -335,7 +335,7 @@
 			for (int i = 1; i < cname.Length; i++) {
 				if (Char.IsUpper (cname[i])) {
 					if (i == 1 && cname[0] == 'G')
-						return "GLib." + cname.Substring (1);
+						return "Gst.GLib." + cname.Substring (1);
 					else
 						return cname.Substring (0, i) + "." + cname.Substring (i);
 				}
@@ -398,7 +398,7 @@
 	
 			foreach (string key in dir_info.objects.Keys) {
 				if (GetExpected(key) != ((string) dir_info.objects[key]))
-					sw.WriteLine ("\t\t\tGLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
+					sw.WriteLine ("\t\t\tGst.GLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
 			}
 					
 			sw.WriteLine ("\t\t}");
diff -Naur generator-upstream/OpaqueGen.cs generator/OpaqueGen.cs
--- generator-upstream/OpaqueGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/OpaqueGen.cs	2009-09-11 08:32:06.000000000 +0200
@@ -32,7 +32,7 @@
 	
 		public override string FromNative(string var, bool owned)
 		{
-			return var + " == IntPtr.Zero ? null : (" + QualifiedName + ") GLib.Opaque.GetOpaque (" + var + ", typeof (" + QualifiedName + "), " + (owned ? "true" : "false") + ")";
+			return var + " == IntPtr.Zero ? null : (" + QualifiedName + ") Gst.GLib.Opaque.GetOpaque (" + var + ", typeof (" + QualifiedName + "), " + (owned ? "true" : "false") + ")";
 		}
 
 		private bool DisableRawCtor {
@@ -68,7 +68,7 @@
 			if (cs_parent != "")
 				sw.Write (" : " + cs_parent);
 			else
-				sw.Write (" : GLib.Opaque");
+				sw.Write (" : Gst.GLib.Opaque");
 
 			foreach (string iface in managed_interfaces) {
 				if (Parent != null && Parent.Implements (iface))
@@ -165,7 +165,7 @@
 				sw.WriteLine ("\t\t\tif (!Owned)");
 				sw.WriteLine ("\t\t\t\treturn;");
 				sw.WriteLine ("\t\t\tFinalizerInfo info = new FinalizerInfo (Handle);");
-				sw.WriteLine ("\t\t\tGLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));");
+				sw.WriteLine ("\t\t\tGst.GLib.Timeout.Add (50, new Gst.GLib.TimeoutHandler (info.Handler));");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 			}
@@ -173,9 +173,9 @@
 #if false
 			Method copy = Methods ["Copy"] as Method;
 			if (copy != null && copy.Parameters.Count == 0) {
-				sw.WriteLine ("\t\tprotected override GLib.Opaque Copy (IntPtr raw)");
+				sw.WriteLine ("\t\tprotected override Gst.GLib.Opaque Copy (IntPtr raw)");
 				sw.WriteLine ("\t\t{");
-				sw.WriteLine ("\t\t\tGLib.Opaque result = new " + QualifiedName + " (" + copy.CName + " (raw));");
+				sw.WriteLine ("\t\t\tGst.GLib.Opaque result = new " + QualifiedName + " (" + copy.CName + " (raw));");
 				sw.WriteLine ("\t\t\tresult.Owned = true;");
 				sw.WriteLine ("\t\t\treturn result;");
 				sw.WriteLine ("\t\t}");
diff -Naur generator-upstream/Parameters.cs generator/Parameters.cs
--- generator-upstream/Parameters.cs	2009-07-13 00:01:52.000000000 +0200
+++ generator/Parameters.cs	2009-09-11 08:32:06.000000000 +0200
@@ -263,9 +263,9 @@
 				} else if (gen is IManualMarshaler)
 					call_parm = "native_" + CallName;
 				else if (gen is ObjectBase)
-					call_parm = (gen as ObjectBase).CallByName (CallName, Owned);
+					call_parm = (gen as ObjectBase).CallByName(CallName, Owned);
 				else
-					call_parm = gen.CallByName (CallName);
+					call_parm = gen.CallByName(CallName);
 			
 				return call_parm;
 			}
diff -Naur generator-upstream/Parser.cs generator/Parser.cs
--- generator-upstream/Parser.cs	2009-04-13 19:44:48.000000000 +0200
+++ generator/Parser.cs	2009-09-11 08:32:06.000000000 +0200
@@ -138,6 +138,9 @@
 				case "object":
 					result.Add (new ObjectGen (ns, elem));
 					break;
+				case "mini-object":
+					result.Add (new MiniObjectGen (ns, elem));
+					break;
 				case "class":
 					result.Add (new ClassGen (ns, elem));
 					break;
diff -Naur generator-upstream/Property.cs generator/Property.cs
--- generator-upstream/Property.cs	2008-09-17 01:21:50.000000000 +0200
+++ generator/Property.cs	2009-09-11 08:32:06.000000000 +0200
@@ -64,7 +64,7 @@
 		}
 
 		protected virtual string PropertyAttribute (string qpname) {
-			return "[GLib.Property (" + qpname + ")]";
+			return "[Gst.GLib.Property (" + qpname + ")]";
 		}
 
 		protected virtual string RawGetter (string qpname) {
@@ -117,9 +117,9 @@
 
 			string v_type = "";
 			if (table.IsInterface (CType)) {
-				v_type = "(GLib.Object)";
+				v_type = "(Gst.GLib.Object)";
 			} else if (table.IsOpaque (CType)) {
-				v_type = "(GLib.Opaque)";
+				v_type = "(Gst.GLib.Opaque)";
 			} else if (table.IsEnum (CType)) {
 				v_type = "(Enum)";
 			}
@@ -140,12 +140,12 @@
 				sw.WriteLine();
 			} else if (Readable) {
 				sw.WriteLine(indent + "get {");
-				sw.WriteLine(indent + "\tGLib.Value val = " + RawGetter (qpname) + ";");
+				sw.WriteLine(indent + "\tGst.GLib.Value val = " + RawGetter (qpname) + ";");
 				if (table.IsOpaque (CType) || table.IsBoxed (CType)) {
 					sw.WriteLine(indent + "\t" + CSType + " ret = (" + CSType + ") val;");
 				} else if (table.IsInterface (CType)) {
-					// Do we have to dispose the GLib.Object from the GLib.Value?
-					sw.WriteLine (indent + "\t{0} ret = {0}Adapter.GetObject ((GLib.Object) val);", CSType);
+					// Do we have to dispose the Gst.GLib.Object from the Gst.GLib.Value?
+					sw.WriteLine (indent + "\t{0} ret = {0}Adapter.GetObject ((Gst.GLib.Object) val);", CSType);
 				} else {
 					sw.Write(indent + "\t" + CSType + " ret = ");
 					sw.Write ("(" + CSType + ") ");
@@ -166,13 +166,13 @@
 				sw.WriteLine();
 			} else if (Writable) {
 				sw.WriteLine(indent + "set {");
-				sw.Write(indent + "\tGLib.Value val = ");
+				sw.Write(indent + "\tGst.GLib.Value val = ");
 				if (table.IsBoxed (CType)) {
-					sw.WriteLine("(GLib.Value) value;");
+					sw.WriteLine("(Gst.GLib.Value) value;");
 				} else if (table.IsOpaque (CType)) {
-					sw.WriteLine("new GLib.Value(value, \"{0}\");", CType);
+					sw.WriteLine("new Gst.GLib.Value(value, \"{0}\");", CType);
 				} else {
-					sw.Write("new GLib.Value(");
+					sw.Write("new Gst.GLib.Value(");
 					if (v_type != "" && !(table.IsObject (CType) || table.IsInterface (CType) || table.IsOpaque (CType))) {
 						sw.Write(v_type + " ");
 					}
diff -Naur generator-upstream/ReturnValue.cs generator/ReturnValue.cs
--- generator-upstream/ReturnValue.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/ReturnValue.cs	2009-09-11 08:32:06.000000000 +0200
@@ -110,7 +110,9 @@
 			get {
 				if (IGen == null)
 					return String.Empty;
-				return IGen.MarshalType + (is_array || is_null_term ? "[]" : String.Empty);
+				else if (is_null_term)
+					return "IntPtr";
+				return IGen.MarshalType + (is_array ? "[]" : String.Empty);
 			}
 		}
 
@@ -121,14 +123,14 @@
 
 			if (ElementType != String.Empty) {
 				string args = (owned ? "true" : "false") + ", " + (elements_owned ? "true" : "false");
-				if (IGen.QualifiedName == "GLib.PtrArray")
-					return String.Format ("({0}[]) GLib.Marshaller.PtrArrayToArray ({1}, {2}, typeof({0}))", ElementType, var, args);
+				if (IGen.QualifiedName == "Gst.GLib.PtrArray")
+					return String.Format ("({0}[]) Gst.GLib.Marshaller.PtrArrayToArray ({1}, {2}, typeof({0}))", ElementType, var, args);
 				else
-					return String.Format ("({0}[]) GLib.Marshaller.ListPtrToArray ({1}, typeof({2}), {3}, typeof({4}))", ElementType, var, IGen.QualifiedName, args, element_ctype == "gfilename*" ? "GLib.ListBase.FilenameString" : ElementType);
+					return String.Format ("({0}[]) Gst.GLib.Marshaller.ListPtrToArray ({1}, typeof({2}), {3}, typeof({4}))", ElementType, var, IGen.QualifiedName, args, element_ctype == "gfilename*" ? "Gst.GLib.ListBase.FilenameString" : ElementType);
 			} else if (IGen is HandleBase)
 				return ((HandleBase)IGen).FromNative (var, owned);
 			else if (is_null_term)
-				return String.Format ("GLib.Marshaller.NullTermPtrToStringArray ({0}, {1})", var, owned ? "true" : "false");
+				return String.Format ("Gst.Marshaller.NullTermPtrToStringArray ({0}, {1})", var, owned ? "true" : "false");
 			else
 				return IGen.FromNative (var);
 		}
@@ -142,11 +144,11 @@
 				string args = ", typeof (" + ElementType + "), " + (owned ? "true" : "false") + ", " + (elements_owned ? "true" : "false");
 				var = "new " + IGen.QualifiedName + "(" + var + args + ")";
 			} else if (is_null_term)
-				return String.Format ("GLib.Marshaller.StringArrayToNullTermPointer ({0})", var);
+				return String.Format ("Gst.Marshaller.StringArrayToNullTermPointer ({0})", var);
 
 			if (IGen is IManualMarshaler)
 				return (IGen as IManualMarshaler).AllocNative (var);
-			else if (IGen is ObjectGen && owned)
+			else if ((IGen is ObjectGen || IGen is MiniObjectGen) && owned)
 				return var + " == null ? IntPtr.Zero : " + var + ".OwnedHandle";
 			else if (IGen is OpaqueGen && owned)
 				return var + " == null ? IntPtr.Zero : " + var + ".OwnedCopy";
diff -Naur generator-upstream/Signal.cs generator/Signal.cs
--- generator-upstream/Signal.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/Signal.cs	2009-09-11 08:32:06.000000000 +0200
@@ -204,7 +204,7 @@
 			}
 			sw.WriteLine("\t\t\t} catch (Exception) {");
 			sw.WriteLine ("\t\t\t\tException ex = new Exception (\"args.RetVal or 'out' property unset or set to incorrect type in " + EventHandlerQualifiedName + " callback\");");
-			sw.WriteLine("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (ex, true);");
+			sw.WriteLine("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (ex, true);");
 			
 			sw.WriteLine ("\t\t\t\t// NOTREACHED: above call doesn't return.");
 			sw.WriteLine ("\t\t\t\tthrow ex;");
@@ -228,15 +228,15 @@
 			sw.WriteLine("\t\t{");
 			sw.WriteLine("\t\t\t{0} args = new {0} ();", EventArgsQualifiedName);
 			sw.WriteLine("\t\t\ttry {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = ((GCHandle) gch).Target as Gst.GLib.Signal;");
 			sw.WriteLine("\t\t\t\tif (sig == null)");
 			sw.WriteLine("\t\t\t\t\tthrow new Exception(\"Unknown signal GC handle received \" + gch);");
 			sw.WriteLine();
 			string finish = GenArgsInitialization (sw);
 			sw.WriteLine("\t\t\t\t{0} handler = ({0}) sig.Handler;", EventHandlerQualifiedName);
-			sw.WriteLine("\t\t\t\thandler (GLib.Object.GetObject (inst), args);");
+			sw.WriteLine("\t\t\t\thandler (Gst.GLib.Object.GetObject (inst), args);");
 			sw.WriteLine("\t\t\t} catch (Exception e) {");
-			sw.WriteLine("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, false);");
+			sw.WriteLine("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, false);");
 			sw.WriteLine("\t\t\t}");
 			GenArgsCleanup (sw, finish);
 			sw.WriteLine("\t\t}");
@@ -266,7 +266,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\tpublic delegate void " + EventHandlerName + "(object o, " + EventArgsName + " args);");
 			sw.WriteLine ();
-			sw.WriteLine ("\tpublic class " + EventArgsName + " : GLib.SignalArgs {");
+			sw.WriteLine ("\tpublic class " + EventArgsName + " : Gst.GLib.SignalArgs {");
 			for (int i = 0; i < parms.Count; i++) {
 				sw.WriteLine ("\t\tpublic " + parms[i].CSType + " " + parms[i].StudlyName + "{");
 				if (parms[i].PassAs != "out") {
@@ -296,17 +296,17 @@
 				args_type = ", new " + DelegateName + "(" + CallbackName + ")";
 			}
 
-			sw.WriteLine("\t\t[GLib.Signal("+ CName + ")]");
+			sw.WriteLine("\t\t[Gst.GLib.Signal("+ CName + ")]");
 			sw.Write("\t\tpublic ");
 			if (NeedNew (implementor))
 				sw.Write("new ");
 			sw.WriteLine("event " + EventHandlerQualifiedName + " " + Name + " {");
 			sw.WriteLine("\t\t\tadd {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = Gst.GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
 			sw.WriteLine("\t\t\t\tsig.AddDelegate (value);");
 			sw.WriteLine("\t\t\t}");
 			sw.WriteLine("\t\t\tremove {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = Gst.GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
 			sw.WriteLine("\t\t\t\tsig.RemoveDelegate (value);");
 			sw.WriteLine("\t\t\t}");
 			sw.WriteLine("\t\t}");
diff -Naur generator-upstream/StructBase.cs generator/StructBase.cs
--- generator-upstream/StructBase.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/StructBase.cs	2009-09-11 08:32:06.000000000 +0200
@@ -92,7 +92,7 @@
 		
 		public string AllocNative (string var)
 		{
-			return "GLib.Marshaller.StructureToPtrAlloc (" + var + ")";
+			return "Gst.GLib.Marshaller.StructureToPtrAlloc (" + var + ")";
 		}
 
 		public string ReleaseNative (string var)
diff -Naur generator-upstream/StructGen.cs generator/StructGen.cs
--- generator-upstream/StructGen.cs	2005-08-05 22:34:45.000000000 +0200
+++ generator/StructGen.cs	2009-09-11 08:32:06.000000000 +0200
@@ -36,8 +36,8 @@
 			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
 			base.Generate (gen_info);
 			if (GetMethod ("GetType") == null && GetMethod ("GetGType") == null) {
-				sw.WriteLine ("\t\tprivate static GLib.GType GType {");
-				sw.WriteLine ("\t\t\tget { return GLib.GType.Pointer; }");
+				sw.WriteLine ("\t\tprivate static Gst.GLib.GType GType {");
+				sw.WriteLine ("\t\t\tget { return Gst.GLib.GType.Pointer; }");
 				sw.WriteLine ("\t\t}");
 			}
 			sw.WriteLine ("#endregion");
diff -Naur generator-upstream/SymbolTable.cs generator/SymbolTable.cs
--- generator-upstream/SymbolTable.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/SymbolTable.cs	2009-09-11 08:32:06.000000000 +0200
@@ -108,23 +108,24 @@
 			AddType (new ConstStringGen ("const-xmlChar"));
 			AddType (new ConstStringGen ("const-char"));
 			AddType (new ConstFilenameGen ("const-gfilename"));
-			AddType (new MarshalGen ("gfilename", "string", "IntPtr", "GLib.Marshaller.StringToFilenamePtr({0})", "GLib.Marshaller.FilenamePtrToStringGFree({0})"));
-			AddType (new MarshalGen ("gchar", "string", "IntPtr", "GLib.Marshaller.StringToPtrGStrdup({0})", "GLib.Marshaller.PtrToStringGFree({0})"));
-			AddType (new MarshalGen ("char", "string", "IntPtr", "GLib.Marshaller.StringToPtrGStrdup({0})", "GLib.Marshaller.PtrToStringGFree({0})"));
+			AddType (new MarshalGen ("gfilename", "string", "IntPtr", "Gst.GLib.Marshaller.StringToFilenamePtr({0})", "Gst.GLib.Marshaller.FilenamePtrToStringGFree({0})"));
+			AddType (new MarshalGen ("gchar", "string", "IntPtr", "Gst.GLib.Marshaller.StringToPtrGStrdup({0})", "Gst.GLib.Marshaller.PtrToStringGFree({0})"));
+			AddType (new MarshalGen ("char", "string", "IntPtr", "Gst.GLib.Marshaller.StringToPtrGStrdup({0})", "Gst.GLib.Marshaller.PtrToStringGFree({0})"));
 			AddType (new SimpleGen ("GStrv", "string[]", "null"));
 
 			// manually wrapped types requiring more complex marshaling
-			AddType (new ManualGen ("GInitiallyUnowned", "GLib.InitiallyUnowned", "GLib.Object.GetObject ({0})"));
-			AddType (new ManualGen ("GObject", "GLib.Object", "GLib.Object.GetObject ({0})"));
-			AddType (new ManualGen ("GList", "GLib.List"));
-			AddType (new ManualGen ("GPtrArray", "GLib.PtrArray"));
-			AddType (new ManualGen ("GSList", "GLib.SList"));
-			AddType (new MarshalGen ("gunichar", "char", "uint", "GLib.Marshaller.CharToGUnichar ({0})", "GLib.Marshaller.GUnicharToChar ({0})"));
-			AddType (new MarshalGen ("time_t", "System.DateTime", "IntPtr", "GLib.Marshaller.DateTimeTotime_t ({0})", "GLib.Marshaller.time_tToDateTime ({0})"));
-			AddType (new MarshalGen ("GString", "string", "IntPtr", "new GLib.GString ({0}).Handle", "GLib.GString.PtrToString ({0})"));
-			AddType (new MarshalGen ("GType", "GLib.GType", "IntPtr", "{0}.Val", "new GLib.GType({0})", "GLib.GType.None"));
-			AddType (new ByRefGen ("GValue", "GLib.Value"));
-			AddType (new SimpleGen ("GDestroyNotify", "GLib.DestroyNotify", "null"));
+			AddType (new ManualGen ("GInitiallyUnowned", "Gst.GLib.InitiallyUnowned", "Gst.GLib.Object.GetObject ({0})"));
+			AddType (new ManualGen ("GObject", "Gst.GLib.Object", "Gst.GLib.Object.GetObject ({0})"));
+			AddType (new ManualGen ("GstMiniObject", "Gst.MiniObject", "Gst.MiniObject.GetObject ({0})"));
+			AddType (new ManualGen ("GList", "Gst.GLib.List"));
+			AddType (new ManualGen ("GPtrArray", "Gst.GLib.PtrArray"));
+			AddType (new ManualGen ("GSList", "Gst.GLib.SList"));
+			AddType (new MarshalGen ("gunichar", "char", "uint", "Gst.GLib.Marshaller.CharToGUnichar ({0})", "Gst.GLib.Marshaller.GUnicharToChar ({0})"));
+			AddType (new MarshalGen ("time_t", "System.DateTime", "IntPtr", "Gst.GLib.Marshaller.DateTimeTotime_t ({0})", "Gst.GLib.Marshaller.time_tToDateTime ({0})"));
+			AddType (new MarshalGen ("GString", "string", "IntPtr", "new Gst.GLib.GString ({0}).Handle", "Gst.GLib.GString.PtrToString ({0})"));
+			AddType (new MarshalGen ("GType", "Gst.GLib.GType", "IntPtr", "{0}.Val", "new Gst.GLib.GType({0})", "Gst.GLib.GType.None"));
+			AddType (new ByRefGen ("GValue", "Gst.GLib.Value"));
+			AddType (new SimpleGen ("GDestroyNotify", "Gst.GLib.DestroyNotify", "null"));
 
 			// FIXME: These ought to be handled properly.
 			AddType (new SimpleGen ("GC", "IntPtr", "IntPtr.Zero"));
@@ -136,7 +137,7 @@
 			AddType (new SimpleGen ("GByteArray", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GData", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GIOChannel", "IntPtr", "IntPtr.Zero"));
-			AddType (new SimpleGen ("GTypeModule", "GLib.Object", "null"));
+			AddType (new SimpleGen ("GTypeModule", "Gst.GLib.Object", "null"));
 			AddType (new SimpleGen ("GHashTable", "System.IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("va_list", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GParamSpec", "IntPtr", "IntPtr.Zero"));
@@ -306,7 +307,8 @@
 			
 		public bool IsObject(string c_type)
 		{
-			if (this[c_type] is ObjectGen)
+			if ((this[c_type] is ObjectGen) ||
+			    (this[c_type] is MiniObjectGen))
 				return true;
 
 			return false;
diff -Naur generator-upstream/VirtualMethod.cs generator/VirtualMethod.cs
--- generator-upstream/VirtualMethod.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/VirtualMethod.cs	2009-09-11 08:32:06.000000000 +0200
@@ -92,7 +92,7 @@
 				else
 					type = this.container_type.Name;
 
-				sw.WriteLine ("\t\t\t\t{0} __obj = GLib.Object.GetObject (inst, false) as {0};", type);
+				sw.WriteLine ("\t\t\t\t{0} __obj = Gst.GLib.Object.GetObject (inst, false) as {0};", type);
 			}
 
 			sw.Write (call.Setup ("\t\t\t\t"));
@@ -108,7 +108,7 @@
 
 			bool fatal = parms.HasOutParam || !retval.IsVoid;
 			sw.WriteLine ("\t\t\t} catch (Exception e) {");
-			sw.WriteLine ("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
+			sw.WriteLine ("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
 			if (fatal) {
 				sw.WriteLine ("\t\t\t\t// NOTREACHED: above call does not return.");
 				sw.WriteLine ("\t\t\t\tthrow e;");
