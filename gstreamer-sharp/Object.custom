public object this[string property] {
  get {
    return GetProperty (property).Val;
  }
  set {
    GLib.Value v = new GLib.Value (this, property);
    v.Val = value;
    SetProperty (property, v);
    v.Dispose ();
  }
}

[StructLayout (LayoutKind.Sequential) ]
struct GTypeInstance {
  public IntPtr g_class;
}

[StructLayout (LayoutKind.Sequential) ]
struct GParamSpec {
  public GTypeInstance instance;
  IntPtr name;
  public int Flags;
  public IntPtr ValueType;
  public IntPtr OwnerType;
}

[DllImport ("libgobject-2.0-0.dll") ]
static extern IntPtr g_object_class_list_properties (IntPtr klass, out uint n_properties);

[DllImport ("libgobject-2.0-0.dll") ]
static extern IntPtr g_param_spec_get_name (IntPtr pspec);

[DllImport ("libgobject-2.0-0.dll") ]
static extern IntPtr g_param_spec_get_nick (IntPtr pspec);

[DllImport ("libgobject-2.0-0.dll") ]
static extern IntPtr g_param_spec_get_blurb (IntPtr pspec);

[DllImport ("libgobject-2.0-0.dll") ]
static extern void g_param_value_set_default (IntPtr pspec, ref GLib.Value val);

[DllImport ("gstreamersharpglue-0.10") ]
static extern bool gstsharp_g_param_spec_get_range (IntPtr pspec, ref GLib.Value min, ref GLib.Value max);

public PropertyInfo[] Properties {
  get {
    uint n_properties;
    IntPtr klass = Marshal.ReadIntPtr (Handle);
    IntPtr properties = g_object_class_list_properties (klass, out n_properties);

    PropertyInfo[] ret = new PropertyInfo[n_properties];
    for (int i = 0; i < n_properties; i++) {
      IntPtr pspec_ptr = Marshal.ReadIntPtr (properties, i * IntPtr.Size);
      GParamSpec pspec = (GParamSpec) Marshal.PtrToStructure (pspec_ptr, typeof (GParamSpec));
      IntPtr name = g_param_spec_get_name (pspec_ptr);
      IntPtr nick = g_param_spec_get_nick (pspec_ptr);
      IntPtr blurb = g_param_spec_get_blurb (pspec_ptr);

      ret[i].name = GLib.Marshaller.Utf8PtrToString (name);
      ret[i].nick = GLib.Marshaller.Utf8PtrToString (nick);
      ret[i].blurb = GLib.Marshaller.Utf8PtrToString (blurb);

      ret[i].readable = ( (pspec.Flags & (1 << 0)) != 0);
      ret[i].writeable = ( (pspec.Flags & (1 << 1)) != 0);
      ret[i].controllable = ( (pspec.Flags & (1 << 9)) != 0);
      /* TODO: Add more flags later, like the mutable flags */

      ret[i].gtype = new GLib.GType (pspec.ValueType);
      ret[i].type = (System.Type) ret[i].gtype;

      try {
        GLib.Value v = new GLib.Value (new GLib.GType (pspec.ValueType));
        g_param_value_set_default (pspec_ptr, ref v);
        ret[i].dflt = v.Val;
        v.Dispose ();

        if (EnumInfo.IsEnumType (ret[i].gtype)) {
          EnumInfo ei = new EnumInfo (ret[i].gtype);
          ret[i].min = ei.Min;
          ret[i].max = ei.Max;
        } else {
          GLib.Value min = new GLib.Value (new GLib.GType (pspec.ValueType));
          GLib.Value max = new GLib.Value (new GLib.GType (pspec.ValueType));
          if (gstsharp_g_param_spec_get_range (pspec_ptr, ref min, ref max)) {
            ret[i].min = (object) min.Val;
            ret[i].max = (object) max.Val;
          }
          min.Dispose ();
          max.Dispose ();
        }
      } catch (Exception) {}
    }

    GLib.Marshaller.Free (properties);

    return ret;
  }
}

public void Connect (string signal, DynamicSignalHandler handler) {
  DynamicSignal.Connect (this, signal, handler);
}

public void Disconnect (string signal, DynamicSignalHandler handler) {
  DynamicSignal.Disconnect (this, signal, handler);
}

public object Emit (string signal, params object[] parameters) {
  return DynamicSignal.Emit (this, signal, parameters);
}

[DllImport ("gstreamer-0.10.dll") ]
static extern void gst_object_sink (IntPtr raw);
[DllImport ("gstreamer-0.10.dll") ]
static extern IntPtr gst_object_ref (IntPtr raw);

protected override IntPtr Raw {
  get {
    return base.Raw;
  }
  set {
    if (value != IntPtr.Zero) {
      gst_object_ref (value);
      gst_object_sink (value);
    }
    base.Raw = value;
  }
}


[DllImport ("gstreamer-0.10.dll") ]
static extern bool gst_object_set_parent (IntPtr raw, IntPtr parent);
[DllImport ("gstreamer-0.10.dll") ]
static extern IntPtr gst_object_get_parent (IntPtr raw);

public Gst.Object Parent {
  set {
    bool raw_ret = gst_object_set_parent (Handle, value == null ? IntPtr.Zero : value.Handle);
    if (!raw_ret)
      throw new ApplicationException ();
  }
  get {
    IntPtr raw_ret = gst_object_get_parent (Handle);
    Gst.Object ret = GLib.Object.GetObject (raw_ret, true) as Gst.Object;
    return ret;
  }
}

[DllImport ("gstreamersharpglue-0.10") ]
extern static uint gstsharp_gst_object_get_lock_offset ();

static uint lock_offset = gstsharp_gst_object_get_lock_offset ();
internal IntPtr LockPtr {
  get {
    unsafe {
      IntPtr* raw_ptr = (IntPtr*) ( ( (byte*) Handle) + lock_offset);
      return (*raw_ptr);
    }
  }
}

[DllImport ("libglib-2.0-0.dll") ]
static extern void g_mutex_lock (IntPtr mutex);
[DllImport ("libglib-2.0-0.dll") ]
static extern void g_mutex_unlock (IntPtr mutex);
[DllImport ("libglib-2.0-0.dll") ]
static extern bool g_mutex_trylock (IntPtr mutex);

public void Lock () {
  g_mutex_lock (LockPtr);
}

public void Unlock () {
  g_mutex_unlock (LockPtr);
}

public bool TryLock () {
  return g_mutex_trylock (LockPtr);
}

[DllImport ("gstreamer-0.10.dll") ]
static extern bool gst_object_check_uniqueness (IntPtr list, IntPtr name);

public static bool CheckUniqueness (Gst.Object[] objects, string name) {
  GLib.List list = new GLib.List (objects, typeof (Gst.Object), false, false);
  IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
  bool raw_ret = gst_object_check_uniqueness (list.Handle, native_name);
  bool ret = raw_ret;
  GLib.Marshaller.Free (native_name);
  return ret;
}
