<MACRO>
<NAME>GES_PADDING</NAME>
#define GES_PADDING		4
</MACRO>
<STRUCT>
<NAME>GESCustomTimelineSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESCustomTimelineSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimeline</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOperationClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipeline</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipelineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransitionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineStandardTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineStandardTransitionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTestSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTestSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTitleSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTitleSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOverlayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTextOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTextOverlayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrack</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackOperation</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackOperationClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackImageSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackImageSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTransitionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTestSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTestSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTitleSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTextOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GESFormatter</NAME>
</STRUCT>
<STRUCT>
<NAME>GESFormatterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESKeyfileFormatter</NAME>
</STRUCT>
<STRUCT>
<NAME>GESKeyfileFormatterClass</NAME>
</STRUCT>
<MACRO>
<NAME>GES_TYPE_TRACK_TRANSITION</NAME>
#define GES_TYPE_TRACK_TRANSITION ges_track_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_TRANSITION</NAME>
#define GES_TRACK_TRANSITION(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_TRANSITION,\
        GESTrackTransition))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TRANSITION_CLASS</NAME>
#define GES_TRACK_TRANSITION_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_TRANSITION,\
        GESTrackTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TRANSITION</NAME>
#define GES_IS_TRACK_TRANSITION(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TRANSITION_CLASS</NAME>
#define GES_IS_TRACK_TRANSITION_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TRANSITION_GET_CLASS</NAME>
#define GES_TRACK_TRANSITION_GET_CLASS(obj) \
    (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_TRANSITION,\
        GESTrackTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTrackTransitionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTransition</NAME>
struct _GESTrackTransition
{
  /*< private >*/
  GESTrackOperation parent;

  GESTrackTransitionPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackTransitionClass</NAME>
struct _GESTrackTransitionClass {
  /*< private >*/
  GESTrackOperationClass parent_class;
  
  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_SOURCE</NAME>
#define GES_TYPE_TIMELINE_SOURCE ges_timeline_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE</NAME>
#define GES_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_SOURCE, GESTimelineSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE_CLASS</NAME>
#define GES_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_SOURCE, GESTimelineSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_SOURCE</NAME>
#define GES_IS_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_SOURCE, GESTimelineSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineSource</NAME>
struct _GESTimelineSource {
  GESTimelineObject parent;

  /*< private >*/
  GESTimelineSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineSourceClass</NAME>
struct _GESTimelineSourceClass {
  /*< private >*/
  GESTimelineObjectClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_FORMATTER</NAME>
#define GES_TYPE_FORMATTER ges_formatter_get_type()
</MACRO>
<MACRO>
<NAME>GES_FORMATTER</NAME>
#define GES_FORMATTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_FORMATTER, GESFormatter))
</MACRO>
<MACRO>
<NAME>GES_FORMATTER_CLASS</NAME>
#define GES_FORMATTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_FORMATTER, GESFormatterClass))
</MACRO>
<MACRO>
<NAME>GES_IS_FORMATTER</NAME>
#define GES_IS_FORMATTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_FORMATTER))
</MACRO>
<MACRO>
<NAME>GES_IS_FORMATTER_CLASS</NAME>
#define GES_IS_FORMATTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_FORMATTER))
</MACRO>
<MACRO>
<NAME>GES_FORMATTER_GET_CLASS</NAME>
#define GES_FORMATTER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_FORMATTER, GESFormatterClass))
</MACRO>
<STRUCT>
<NAME>GESFormatter</NAME>
struct _GESFormatter {
  GObject parent;

  /*< private >*/
  gchar    *data;
  gsize    length;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<USER_FUNCTION>
<NAME>GESFormatterCanLoadURIMethod</NAME>
<RETURNS>gboolean </RETURNS>
gchar * uri
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESFormatterCanSaveURIMethod</NAME>
<RETURNS>gboolean </RETURNS>
gchar * uri
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESFormatterLoadFromURIMethod</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter *formatter,
						     GESTimeline *timeline,
						     gchar * uri
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESFormatterSaveToURIMethod</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter *formatter,
						   GESTimeline *timeline,
						   gchar * uri
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESFormatterSaveMethod</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter,
					      GESTimeline * timeline
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESFormatterLoadMethod</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter,
					      GESTimeline * timeline
</USER_FUNCTION>
<STRUCT>
<NAME>GESFormatterClass</NAME>
struct _GESFormatterClass {
  GObjectClass parent_class;

  /* FIXME : formatter name */
  /* FIXME : formatter description */
  /* FIXME : format name/mime-type */

  GESFormatterCanLoadURIMethod can_load_uri;
  GESFormatterCanSaveURIMethod can_save_uri;
  GESFormatterLoadFromURIMethod load_from_uri;
  GESFormatterSaveToURIMethod save_to_uri;

  /*< private >*/
  GESFormatterSaveMethod save;
  GESFormatterLoadMethod load;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_formatter_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_new_for_uri</NAME>
<RETURNS>GESFormatter *</RETURNS>
gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_default_formatter_new</NAME>
<RETURNS>GESFormatter *</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_can_load_uri</NAME>
<RETURNS>gboolean </RETURNS>
gchar * uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_can_save_uri</NAME>
<RETURNS>gboolean </RETURNS>
gchar * uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_load_from_uri</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter, GESTimeline  *timeline, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_save_to_uri</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter, GESTimeline *timeline, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_load</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_save</NAME>
<RETURNS>gboolean </RETURNS>
GESFormatter * formatter, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_set_data</NAME>
<RETURNS>void </RETURNS>
GESFormatter * formatter, void *data, gsize length 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_get_data</NAME>
<RETURNS>void *</RETURNS>
GESFormatter *formatter, gsize *length 
</FUNCTION>
<FUNCTION>
<NAME>ges_formatter_clear_data</NAME>
<RETURNS>void </RETURNS>
GESFormatter *formatter 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_OPERATION</NAME>
#define GES_TYPE_TRACK_OPERATION ges_track_operation_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_OPERATION</NAME>
#define GES_TRACK_OPERATION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_OPERATION, GESTrackOperation))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OPERATION_CLASS</NAME>
#define GES_TRACK_OPERATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_OPERATION, GESTrackOperationClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OPERATION</NAME>
#define GES_IS_TRACK_OPERATION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_OPERATION))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OPERATION_CLASS</NAME>
#define GES_IS_TRACK_OPERATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_OPERATION))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OPERATION_GET_CLASS</NAME>
#define GES_TRACK_OPERATION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_OPERATION, GESTrackOperationClass))
</MACRO>
<STRUCT>
<NAME>GESTrackOperationPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackOperation</NAME>
struct _GESTrackOperation {
  /*< private >*/
  GESTrackObject parent;

  GESTrackOperationPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackOperationClass</NAME>
struct _GESTrackOperationClass {
  /*< private >*/
  GESTrackObjectClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_operation_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_TEXT_OVERLAY</NAME>
#define GES_TYPE_TIMELINE_TEXT_OVERLAY ges_timeline_text_overlay_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEXT_OVERLAY</NAME>
#define GES_TIMELINE_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_TEXT_OVERLAY, GESTimelineTextOverlay))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEXT_OVERLAY_CLASS</NAME>
#define GES_TIMELINE_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_TEXT_OVERLAY, GESTimelineTextOverlayClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TEXT_OVERLAY</NAME>
#define GES_IS_TIMELINE_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TEXT_OVERLAY_CLASS</NAME>
#define GES_IS_TIMELINE_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEXT_OVERLAY_GET_CLASS</NAME>
#define GES_TIMELINE_TEXT_OVERLAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_TEXT_OVERLAY, GESTimelineTextOverlayClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineTextOverlayPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTextOverlay</NAME>
struct _GESTimelineTextOverlay {
  /*< private >*/
  GESTimelineOverlay parent;

  gboolean mute;
  gchar *text;
  gchar *font_desc;
  GESTextHAlign halign;
  GESTextVAlign valign;

  GESTimelineTextOverlayPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineTextOverlayClass</NAME>
struct _GESTimelineTextOverlayClass {
  /*< private >*/

  GESTimelineOverlayClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_text_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_text_overlay_new</NAME>
<RETURNS>GESTimelineTextOverlay*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_TRANSITION</NAME>
#define GES_TYPE_TIMELINE_TRANSITION ges_timeline_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION</NAME>
#define GES_TIMELINE_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransition))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION_CLASS</NAME>
#define GES_TIMELINE_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TRANSITION</NAME>
#define GES_IS_TIMELINE_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TRANSITION_CLASS</NAME>
#define GES_IS_TIMELINE_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION_GET_CLASS</NAME>
#define GES_TIMELINE_TRANSITION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineTransitionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransition</NAME>
struct _GESTimelineTransition {
  /*< private >*/
  GESTimelineOperation parent;

  /*< private >*/
  GESTimelineTransitionPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransitionClass</NAME>
struct _GESTimelineTransitionClass {
  /*< private >*/
  GESTimelineOperationClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_init</NAME>
<RETURNS>void </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_TYPE</NAME>
#define GES_TYPE_TRACK_TYPE (ges_track_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>ges_track_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GESTrackType</NAME>
typedef enum {
  GES_TRACK_TYPE_UNKNOWN = 1 << 0,
  GES_TRACK_TYPE_AUDIO   = 1 << 1,
  GES_TRACK_TYPE_VIDEO   = 1 << 2,
  GES_TRACK_TYPE_TEXT    = 1 << 3,
  GES_TRACK_TYPE_CUSTOM  = 1 << 4,
} GESTrackType;
</ENUM>
<ENUM>
<NAME>GESVideoStandardTransitionType</NAME>
typedef enum {
  GES_VIDEO_STANDARD_TRANSITION_TYPE_NONE = 0,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BAR_WIPE_LR = 1,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BAR_WIPE_TB = 2,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TL = 3,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TR = 4,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BR = 5,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BL = 6,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FOUR_BOX_WIPE_CI = 7,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FOUR_BOX_WIPE_CO = 8,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_V = 21,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_H = 22,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TC = 23,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_RC = 24,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BC = 25,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_LC = 26,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DIAGONAL_TL = 41,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DIAGONAL_TR = 42,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOWTIE_V = 43,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BOWTIE_H = 44,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_DBL = 45,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_DTL = 46,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_MISC_DIAGONAL_DBD = 47,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_MISC_DIAGONAL_DD = 48,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_D = 61,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_L = 62,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_U = 63,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_R = 64,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_D = 65,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_L = 66,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_U = 67,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_R = 68,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_IRIS_RECT = 101,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW12 = 201,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW3 = 202,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW6 = 203,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW9 = 204,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_TBV = 205,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_TBH = 206,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_FB = 207,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_CT = 211,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_CR = 212,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FOV = 213,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FOH = 214,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWT = 221,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWR = 222,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWB = 223,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWL = 224,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PV = 225,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PD = 226,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_OV = 227,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_OH = 228,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_T = 231,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_R = 232,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_B = 233,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_L = 234,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FIV = 235,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FIH = 236,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWTL = 241,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWBL = 242,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWBR = 243,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWTR = 244,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PDTL = 245,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PDBL = 246,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_T = 251,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_L = 252,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_B = 253,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_R = 254,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_R = 261,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_U = 262,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_V = 263,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_H = 264,
  GES_VIDEO_STANDARD_TRANSITION_TYPE_CROSSFADE = 512
} GESVideoStandardTransitionType;
</ENUM>
<MACRO>
<NAME>GES_VIDEO_STANDARD_TRANSITION_TYPE_TYPE</NAME>
#define GES_VIDEO_STANDARD_TRANSITION_TYPE_TYPE \
    (ges_video_standard_transition_type_get_type())
</MACRO>
<FUNCTION>
<NAME>ges_video_standard_transition_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GESTextVAlign</NAME>
typedef enum {
    GES_TEXT_VALIGN_BASELINE,
    GES_TEXT_VALIGN_BOTTOM,
    GES_TEXT_VALIGN_TOP
} GESTextVAlign;
</ENUM>
<MACRO>
<NAME>DEFAULT_VALIGNMENT</NAME>
#define DEFAULT_VALIGNMENT GES_TEXT_VALIGN_BASELINE
</MACRO>
<MACRO>
<NAME>GES_TEXT_VALIGN_TYPE</NAME>
#define GES_TEXT_VALIGN_TYPE\
  (ges_text_valign_get_type ())
</MACRO>
<FUNCTION>
<NAME>ges_text_valign_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GESTextHAlign</NAME>
typedef enum {
    GES_TEXT_HALIGN_LEFT,
    GES_TEXT_HALIGN_CENTER,
    GES_TEXT_HALIGN_RIGHT
} GESTextHAlign;
</ENUM>
<MACRO>
<NAME>DEFAULT_HALIGNMENT</NAME>
#define DEFAULT_HALIGNMENT GES_TEXT_HALIGN_CENTER
</MACRO>
<MACRO>
<NAME>GES_TEXT_HALIGN_TYPE</NAME>
#define GES_TEXT_HALIGN_TYPE\
  (ges_text_halign_get_type ())
</MACRO>
<FUNCTION>
<NAME>ges_text_halign_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GESVideoTestPattern</NAME>
typedef enum {
  GES_VIDEO_TEST_PATTERN_SMPTE,
  GES_VIDEO_TEST_PATTERN_SNOW,
  GES_VIDEO_TEST_PATTERN_BLACK,
  GES_VIDEO_TEST_PATTERN_WHITE,
  GES_VIDEO_TEST_PATTERN_RED,
  GES_VIDEO_TEST_PATTERN_GREEN,
  GES_VIDEO_TEST_PATTERN_BLUE,
  GES_VIDEO_TEST_PATTERN_CHECKERS1,
  GES_VIDEO_TEST_PATTERN_CHECKERS2,
  GES_VIDEO_TEST_PATTERN_CHECKERS4,
  GES_VIDEO_TEST_PATTERN_CHECKERS8,
  GES_VIDEO_TEST_PATTERN_CIRCULAR,
  GES_VIDEO_TEST_PATTERN_BLINK,
  GES_VIDEO_TEST_PATTERN_SMPTE75,
} GESVideoTestPattern;
</ENUM>
<MACRO>
<NAME>GES_VIDEO_TEST_PATTERN_TYPE</NAME>
#define GES_VIDEO_TEST_PATTERN_TYPE\
  ges_video_test_pattern_get_type()
</MACRO>
<FUNCTION>
<NAME>ges_video_test_pattern_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_AUDIO_TEST_SOURCE</NAME>
#define GES_TYPE_TRACK_AUDIO_TEST_SOURCE ges_track_audio_test_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TEST_SOURCE</NAME>
#define GES_TRACK_AUDIO_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_AUDIO_TEST_SOURCE, GESTrackAudioTestSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TEST_SOURCE_CLASS</NAME>
#define GES_TRACK_AUDIO_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_AUDIO_TEST_SOURCE, GESTrackAudioTestSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_AUDIO_TEST_SOURCE</NAME>
#define GES_IS_TRACK_AUDIO_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_AUDIO_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_AUDIO_TEST_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_AUDIO_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_AUDIO_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TEST_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_AUDIO_TEST_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_AUDIO_TEST_SOURCE, GESTrackAudioTestSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackAudioTestSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTestSource</NAME>
struct _GESTrackAudioTestSource {
  /*< private >*/
  GESTrackSource parent;

  gdouble freq;
  gdouble volume;

  GESTrackAudioTestSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTestSourceClass</NAME>
struct _GESTrackAudioTestSourceClass {
  /*< private >*/
  GESTrackSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_audio_test_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_test_source_new</NAME>
<RETURNS>GESTrackAudioTestSource*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_test_source_set_freq</NAME>
<RETURNS>void </RETURNS>
GESTrackAudioTestSource *self, gdouble freq 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_test_source_set_volume</NAME>
<RETURNS>void </RETURNS>
GESTrackAudioTestSource *self, gdouble volume 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_STANDARD_TRANSITION</NAME>
#define GES_TYPE_TIMELINE_STANDARD_TRANSITION ges_timeline_standard_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_STANDARD_TRANSITION</NAME>
#define GES_TIMELINE_STANDARD_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_STANDARD_TRANSITION, GESTimelineStandardTransition))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_STANDARD_TRANSITION_CLASS</NAME>
#define GES_TIMELINE_STANDARD_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_STANDARD_TRANSITION, GESTimelineStandardTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_STANDARD_TRANSITION</NAME>
#define GES_IS_TIMELINE_STANDARD_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_STANDARD_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_STANDARD_TRANSITION_CLASS</NAME>
#define GES_IS_TIMELINE_STANDARD_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_STANDARD_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_STANDARD_TRANSITION_GET_CLASS</NAME>
#define GES_TIMELINE_STANDARD_TRANSITION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_STANDARD_TRANSITION, GESTimelineStandardTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineStandardTransitionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineStandardTransition</NAME>
struct _GESTimelineStandardTransition {
  /*< private >*/
  GESTimelineTransition parent;

  /*< public >*/
  GESVideoStandardTransitionType vtype;

  /*< private >*/
  GESTimelineStandardTransitionPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineStandardTransitionClass</NAME>
struct _GESTimelineStandardTransitionClass {
  /*< private >*/
  GESTimelineTransitionClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_standard_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_standard_transition_new</NAME>
<RETURNS>GESTimelineStandardTransition *</RETURNS>
GESVideoStandardTransitionType vtype 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_standard_transition_new_for_nick</NAME>
<RETURNS>GESTimelineStandardTransition *</RETURNS>
char *nick 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_SOURCE</NAME>
#define GES_TYPE_TRACK_SOURCE ges_track_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE</NAME>
#define GES_TRACK_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_SOURCE, GESTrackSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE_CLASS</NAME>
#define GES_TRACK_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_SOURCE, GESTrackSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_SOURCE</NAME>
#define GES_IS_TRACK_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_SOURCE, GESTrackSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackSource</NAME>
struct _GESTrackSource {
  /*< private >*/
  GESTrackObject parent;

  GESTrackSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackSourceClass</NAME>
struct _GESTrackSourceClass {
  /*< private >*/
  GESTrackObjectClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_play_sink_convert_frame</NAME>
<RETURNS>GstBuffer  *</RETURNS>
GstElement * playsink, GstCaps * caps 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK</NAME>
#define GES_TYPE_TRACK ges_track_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK</NAME>
#define GES_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK, GESTrack))
</MACRO>
<MACRO>
<NAME>GES_TRACK_CLASS</NAME>
#define GES_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK, GESTrackClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK</NAME>
#define GES_IS_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_CLASS</NAME>
#define GES_IS_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK))
</MACRO>
<MACRO>
<NAME>GES_TRACK_GET_CLASS</NAME>
#define GES_TRACK_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK, GESTrackClass))
</MACRO>
<STRUCT>
<NAME>GESTrackPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrack</NAME>
struct _GESTrack {
  GstBin parent;

  /*< public >*/
  /* READ-ONLY */
  GESTrackType type;

  GESTrackPrivate * priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackClass</NAME>
struct _GESTrackClass {
  /*< private >*/
  GstBinClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_new</NAME>
<RETURNS>GESTrack*</RETURNS>
GESTrackType type, GstCaps * caps 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_set_timeline</NAME>
<RETURNS>void		</RETURNS>
GESTrack * track, GESTimeline *timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_set_caps</NAME>
<RETURNS>void		</RETURNS>
GESTrack * track, const GstCaps * caps 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_get_caps</NAME>
<RETURNS>const GstCaps *</RETURNS>
GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_get_timeline</NAME>
<RETURNS>const GESTimeline *</RETURNS>
GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTrack * track, GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_remove_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTrack * track, GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_raw_new</NAME>
<RETURNS>GESTrack *</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_raw_new</NAME>
<RETURNS>GESTrack *</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_VIDEO_TEST_SOURCE</NAME>
#define GES_TYPE_TRACK_VIDEO_TEST_SOURCE ges_track_video_test_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TEST_SOURCE</NAME>
#define GES_TRACK_VIDEO_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_VIDEO_TEST_SOURCE, GESTrackVideoTestSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TEST_SOURCE_CLASS</NAME>
#define GES_TRACK_VIDEO_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_VIDEO_TEST_SOURCE, GESTrackVideoTestSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_VIDEO_TEST_SOURCE</NAME>
#define GES_IS_TRACK_VIDEO_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_VIDEO_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_VIDEO_TEST_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_VIDEO_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_VIDEO_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TEST_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_VIDEO_TEST_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_VIDEO_TEST_SOURCE, GESTrackVideoTestSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackVideoTestSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTestSource</NAME>
struct _GESTrackVideoTestSource {
  /*< private >*/
  GESTrackSource parent;

  GESVideoTestPattern pattern;

  GESTrackVideoTestSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTestSourceClass</NAME>
struct _GESTrackVideoTestSourceClass {
  GESTrackSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_video_test_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_test_source_new</NAME>
<RETURNS>GESTrackVideoTestSource*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_test_source_set_pattern</NAME>
<RETURNS>void </RETURNS>
GESTrackVideoTestSource *self, GESVideoTestPattern pattern 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE</NAME>
#define GES_TYPE_TIMELINE ges_timeline_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE</NAME>
#define GES_TIMELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE, GESTimeline))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_CLASS</NAME>
#define GES_TIMELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE, GESTimelineClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE</NAME>
#define GES_IS_TIMELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_CLASS</NAME>
#define GES_IS_TIMELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_GET_CLASS</NAME>
#define GES_TIMELINE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE, GESTimelineClass))
</MACRO>
<STRUCT>
<NAME>GESTimeline</NAME>
struct _GESTimeline {
  GstBin parent;

  /*< private >*/
  GList *layers; /* A list of GESTimelineLayer sorted by priority */
  GList *tracks; /* A list of private track data */

  /* discoverer used for virgin sources */
  GstDiscoverer *discoverer;
  /* Objects that are being discovered FIXME : LOCK ! */
  GList *pendingobjects;
  /* Whether we are changing state asynchronously or not */
  gboolean async_pending;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineClass</NAME>
struct _GESTimelineClass {
  GstBinClass parent_class;

  /*< private >*/

  void (*track_added)	(GESTimeline *timeline, GESTrack * track);
  void (*track_removed)	(GESTimeline *timeline, GESTrack * track);
  void (*layer_added)	(GESTimeline *timeline, GESTimelineLayer *layer);
  void (*layer_removed)	(GESTimeline *timeline, GESTimelineLayer *layer);

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_new</NAME>
<RETURNS>GESTimeline*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_new_from_uri</NAME>
<RETURNS>GESTimeline*</RETURNS>
gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_load_from_uri</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_save_to_uri</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_add_layer</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTimelineLayer *layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_remove_layer</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTimelineLayer *layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_add_track</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_remove_track</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_get_track_for_pad</NAME>
<RETURNS>GESTrack *</RETURNS>
GESTimeline *timeline, GstPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_get_tracks</NAME>
<RETURNS>GList *</RETURNS>
GESTimeline *timeline 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_TEST_SOURCE</NAME>
#define GES_TYPE_TIMELINE_TEST_SOURCE ges_timeline_test_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEST_SOURCE</NAME>
#define GES_TIMELINE_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_TEST_SOURCE, GESTimelineTestSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEST_SOURCE_CLASS</NAME>
#define GES_TIMELINE_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_TEST_SOURCE, GESTimelineTestSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TEST_SOURCE</NAME>
#define GES_IS_TIMELINE_TEST_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TEST_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_TEST_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_TEST_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TEST_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_TEST_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_TEST_SOURCE, GESTimelineTestSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineTestSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTestSource</NAME>
struct _GESTimelineTestSource {
  /*< private >*/
  GESTimelineSource parent;

  gboolean mute;
  GESVideoTestPattern vpattern;
  gdouble freq;
  gdouble volume;
  
  GESTimelineTestSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineTestSourceClass</NAME>
struct _GESTimelineTestSourceClass {
  /*< private >*/
  GESTimelineSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_test_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_test_source_new</NAME>
<RETURNS>GESTimelineTestSource*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_test_source_new_for_nick</NAME>
<RETURNS>GESTimelineTestSource*</RETURNS>
gchar * nick 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_OBJECT</NAME>
#define GES_TYPE_TIMELINE_OBJECT ges_timeline_object_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT</NAME>
#define GES_TIMELINE_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_OBJECT, GESTimelineObject))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_CLASS</NAME>
#define GES_TIMELINE_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_OBJECT, GESTimelineObjectClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OBJECT</NAME>
#define GES_IS_TIMELINE_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OBJECT_CLASS</NAME>
#define GES_IS_TIMELINE_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_GET_CLASS</NAME>
#define GES_TIMELINE_OBJECT_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_OBJECT, GESTimelineObjectClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineObjectPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GESFillTrackObjectFunc</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object,
                    GESTrackObject * trobject,
                    GstElement * gnlobj
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESCreateTrackObjectFunc</NAME>
<RETURNS>GESTrackObject *</RETURNS>
GESTimelineObject * object,
                         GESTrack * track
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GESCreateTrackObjectsFunc</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object,
                                            GESTrack *track
</USER_FUNCTION>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_START</NAME>
#define GES_TIMELINE_OBJECT_START(obj) (((GESTimelineObject*)obj)->start)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_INPOINT</NAME>
#define GES_TIMELINE_OBJECT_INPOINT(obj) (((GESTimelineObject*)obj)->inpoint)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_DURATION</NAME>
#define GES_TIMELINE_OBJECT_DURATION(obj) (((GESTimelineObject*)obj)->duration)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_PRIORITY</NAME>
#define GES_TIMELINE_OBJECT_PRIORITY(obj) (((GESTimelineObject*)obj)->priority)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_HEIGHT</NAME>
#define GES_TIMELINE_OBJECT_HEIGHT(obj) (((GESTimelineObject*)obj)->height)
</MACRO>
<STRUCT>
<NAME>GESTimelineObject</NAME>
struct _GESTimelineObject {
  /*< private >*/
  GObject parent;

  GESTimelineObjectPrivate *priv;
  
  /* We don't add those properties to the priv struct for optimization purposes
   * start, inpoint, duration and fullduration are in nanoseconds */
  guint64 start;    /* position (in time) of the object in the layer */
  guint64 inpoint;  /* in-point */
  guint64 duration; /* duration of the object used in the layer */
  guint32 priority; /* priority of the object in the layer (0:top priority) */
  guint32 height;       /* the span of priorities this object needs */

  guint64 fullduration; /* Full usable duration of the object (-1: no duration) */

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineObjectClass</NAME>
struct _GESTimelineObjectClass {
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  GESCreateTrackObjectFunc create_track_object;
  GESCreateTrackObjectsFunc create_track_objects;

  /* FIXME : might need a release_track_object */
  GESFillTrackObjectFunc  fill_track_object;
  gboolean need_fill_track;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_start</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 start 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_inpoint</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 inpoint 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_duration</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 duration 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_priority</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint priority 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_layer</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, GESTimelineLayer * layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_create_track_object</NAME>
<RETURNS>GESTrackObject  *</RETURNS>
GESTimelineObject * object, GESTrack * track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_create_track_objects</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object, GESTrack * track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_release_track_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object, GESTrackObject * trackobject 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_fill_track_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object, GESTrackObject * trackobj, GstElement * gnlobj 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_find_track_object</NAME>
<RETURNS>GESTrackObject  *</RETURNS>
GESTimelineObject * object, GESTrack * track, GType type 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_get_track_objects</NAME>
<RETURNS>GList  *</RETURNS>
GESTimelineObject *object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_get_layer</NAME>
<RETURNS>GESTimelineLayer  *</RETURNS>
GESTimelineObject *object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_add_track_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject *object, GESTrackObject *trobj 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_new_audio_video</NAME>
<RETURNS>GESTimeline *</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_TYPE_SIMPLE_TIMELINE_LAYER ges_simple_timeline_layer_get_type()
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_SIMPLE_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayer))
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER_CLASS</NAME>
#define GES_SIMPLE_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayerClass))
</MACRO>
<MACRO>
<NAME>GES_IS_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_IS_SIMPLE_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_IS_SIMPLE_TIMELINE_LAYER_CLASS</NAME>
#define GES_IS_SIMPLE_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_SIMPLE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER_GET_CLASS</NAME>
#define GES_SIMPLE_TIMELINE_LAYER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayerClass))
</MACRO>
<STRUCT>
<NAME>GESSimpleTimelineLayerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayer</NAME>
struct _GESSimpleTimelineLayer {
  /*< private >*/
  GESTimelineLayer parent;

  GESSimpleTimelineLayerPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayerClass</NAME>
struct _GESSimpleTimelineLayerClass {
  /*< private >*/
  GESTimelineLayerClass parent_class;

  /*< signals >*/
  void (*object_moved) (GESTimelineLayer * layer, GESTimelineObject * object,
      gint old_position, gint new_position);

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_simple_timeline_layer_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_new</NAME>
<RETURNS>GESSimpleTimelineLayer*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESSimpleTimelineLayer *layer, GESTimelineObject *object, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_move_object</NAME>
<RETURNS>gboolean </RETURNS>
GESSimpleTimelineLayer *layer, GESTimelineObject *object, gint newposition 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_is_valid</NAME>
<RETURNS>gboolean </RETURNS>
GESSimpleTimelineLayer *layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_nth</NAME>
<RETURNS>const GESTimelineObject  *</RETURNS>
GESSimpleTimelineLayer *layer, gint position 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_IMAGE_SOURCE</NAME>
#define GES_TYPE_TRACK_IMAGE_SOURCE ges_track_image_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_IMAGE_SOURCE</NAME>
#define GES_TRACK_IMAGE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_IMAGE_SOURCE, GESTrackImageSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_IMAGE_SOURCE_CLASS</NAME>
#define GES_TRACK_IMAGE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_IMAGE_SOURCE, GESTrackImageSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_IMAGE_SOURCE</NAME>
#define GES_IS_TRACK_IMAGE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_IMAGE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_IMAGE_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_IMAGE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_IMAGE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_IMAGE_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_IMAGE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_IMAGE_SOURCE, GESTrackImageSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackImageSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackImageSource</NAME>
struct _GESTrackImageSource {
  /*< private >*/
  GESTrackSource parent;

  gchar *uri;

  GESTrackImageSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackImageSourceClass</NAME>
struct _GESTrackImageSourceClass {
  GESTrackSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_image_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_image_source_new</NAME>
<RETURNS>GESTrackImageSource*</RETURNS>
gchar *uri 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_LAYER</NAME>
#define GES_TYPE_TIMELINE_LAYER ges_timeline_layer_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER</NAME>
#define GES_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_LAYER, GESTimelineLayer))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER_CLASS</NAME>
#define GES_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_LAYER, GESTimelineLayerClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_LAYER</NAME>
#define GES_IS_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_LAYER_CLASS</NAME>
#define GES_IS_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER_GET_CLASS</NAME>
#define GES_TIMELINE_LAYER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_LAYER, GESTimelineLayerClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineLayerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayer</NAME>
struct _GESTimelineLayer {
  GObject parent; 

  /*< public >*/

  GESTimeline *timeline;

  /*< protected >*/
  guint32 min_gnl_priority, max_gnl_priority;

  GESTimelineLayerPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayerClass</NAME>
struct _GESTimelineLayerClass {
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* virtual methods for subclasses */
  GList *(*get_objects) (GESTimelineLayer * layer);

  /*< private >*/
  /* Signals */
  void	(*object_added)		(GESTimelineLayer * layer, GESTimelineObject * object);
  void	(*object_removed)	(GESTimelineLayer * layer, GESTimelineObject * object);

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_layer_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_new</NAME>
<RETURNS>GESTimelineLayer*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_set_timeline</NAME>
<RETURNS>void     </RETURNS>
GESTimelineLayer * layer, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineLayer * layer, GESTimelineObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_remove_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineLayer * layer, GESTimelineObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_set_priority</NAME>
<RETURNS>void     </RETURNS>
GESTimelineLayer * layer, guint priority 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_get_priority</NAME>
<RETURNS>guint    </RETURNS>
GESTimelineLayer * layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_get_objects</NAME>
<RETURNS>GList*</RETURNS>
GESTimelineLayer * layer 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_VIDEO_TRANSITION</NAME>
#define GES_TYPE_TRACK_VIDEO_TRANSITION ges_track_video_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TRANSITION</NAME>
#define GES_TRACK_VIDEO_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_VIDEO_TRANSITION, GESTrackVideoTransition))
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TRANSITION_CLASS</NAME>
#define GES_TRACK_VIDEO_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_VIDEO_TRANSITION, GESTrackVideoTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_VIDEO_TRANSITION</NAME>
#define GES_IS_TRACK_VIDEO_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_VIDEO_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_VIDEO_TRANSITION_CLASS</NAME>
#define GES_IS_TRACK_VIDEO_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_VIDEO_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TRACK_VIDEO_TRANSITION_GET_CLASS</NAME>
#define GES_TRACK_VIDEO_TRANSITION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_VIDEO_TRANSITION, GESTrackVideoTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTrackVideoTransitionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTransition</NAME>
struct _GESTrackVideoTransition {
  GESTrackTransition parent;
  
  /*< private >*/
  GESVideoStandardTransitionType        type;
 
  /* these enable video interpolation */
  GstController                 *controller;
  GstInterpolationControlSource *control_source;

  /* so we can support changing between wipes */
  GstElement                    *smpte;
  GstElement                    *mixer;
  GstPad                        *sinka;
  GstPad                        *sinkb;
  
  /* these will be different depending on whether smptealpha or alpha element
   * is used */
  gdouble                       start_value;
  gdouble                       end_value;

  GESTrackVideoTransitionPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackVideoTransitionClass</NAME>
struct _GESTrackVideoTransitionClass {
  GESTrackTransitionClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_video_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_transition_set_type</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackVideoTransition * self, GESVideoStandardTransitionType type 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_transition_new</NAME>
<RETURNS>GESTrackVideoTransition*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_FILE_SOURCE</NAME>
#define GES_TYPE_TIMELINE_FILE_SOURCE ges_timeline_filesource_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE</NAME>
#define GES_TIMELINE_FILE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE_CLASS</NAME>
#define GES_TIMELINE_FILE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_FILE_SOURCE</NAME>
#define GES_IS_TIMELINE_FILE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_FILE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_FILE_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_FILE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_FILE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_FILE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineFileSource</NAME>
struct _GESTimelineFileSource {
  /*< private >*/
  GESTimelineSource parent;

  gchar *uri;

  gboolean mute;
  gboolean is_image;

  guint64 maxduration;

  /* The formats supported by this filesource
   * TODO : Could maybe be moved to a parent class */
  GESTrackType supportedformats;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSourceClass</NAME>
struct _GESTimelineFileSourceClass {
  /*< private >*/
  GESTimelineSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_filesource_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_filesource_new</NAME>
<RETURNS>GESTimelineFileSource*</RETURNS>
gchar *uri 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_OBJECT</NAME>
#define GES_TYPE_TRACK_OBJECT ges_track_object_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT</NAME>
#define GES_TRACK_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_OBJECT, GESTrackObject))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_CLASS</NAME>
#define GES_TRACK_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_OBJECT, GESTrackObjectClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OBJECT</NAME>
#define GES_IS_TRACK_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OBJECT_CLASS</NAME>
#define GES_IS_TRACK_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_GET_CLASS</NAME>
#define GES_TRACK_OBJECT_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_OBJECT, GESTrackObjectClass))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_START</NAME>
#define GES_TRACK_OBJECT_START(obj) (((GESTrackObject*)obj)->start)
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_INPOINT</NAME>
#define GES_TRACK_OBJECT_INPOINT(obj) (((GESTrackObject*)obj)->inpoint)
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_DURATION</NAME>
#define GES_TRACK_OBJECT_DURATION(obj) (((GESTrackObject*)obj)->duration)
</MACRO>
<STRUCT>
<NAME>GESTrackObjectPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackObject</NAME>
struct _GESTrackObject {
  GObject parent;

  /*< public >*/
  /* Cached values of the gnlobject properties */
  guint64 start;
  guint64 inpoint;
  guint64 duration;
  guint32 gnl_priority;
  gboolean active;

  /*< private >*/
  GESTrackObjectPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackObjectClass</NAME>
struct _GESTrackObjectClass {
  /*< private >*/
  GObjectClass parent_class;

  /*< public >*/
  /* virtual methods for subclasses */
  const gchar *gnlobject_factorytype;
  GstElement* (*create_gnl_object) (GESTrackObject * object);
  GstElement* (*create_element) (GESTrackObject * object);

  void (*start_changed) (GESTrackObject *object, guint64 start);
  void (*media_start_changed) (GESTrackObject *object, guint64 media_start);
  void (*gnl_priority_changed) (GESTrackObject *object, guint priority);
  void (*duration_changed) (GESTrackObject *object, guint64 duration);
  void (*active_changed) (GESTrackObject *object, gboolean active);

  /*< private >*/
  /* signals (currently unused) */
  void	(*changed)	(GESTrackObject * object);

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_track</NAME>
<RETURNS>gboolean        </RETURNS>
GESTrackObject * object, GESTrack * track 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_get_track</NAME>
<RETURNS>const GESTrack*</RETURNS>
GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_timeline_object</NAME>
<RETURNS>void </RETURNS>
GESTrackObject * object, GESTimelineObject * tlobject 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_get_timeline_object</NAME>
<RETURNS>const GESTimelineObject *</RETURNS>
GESTrackObject* object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_get_gnlobject</NAME>
<RETURNS>GstElement *</RETURNS>
GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_get_element</NAME>
<RETURNS>GstElement *</RETURNS>
GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_start_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 start 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_inpoint_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 inpoint 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_duration_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 duration 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_priority_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint32 priority 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_priority_offset_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint32 priority_offset 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_get_priority_offset</NAME>
<RETURNS>guint32 </RETURNS>
GESTrackObject *object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_active</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, gboolean active 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_PIPELINE</NAME>
#define GES_TYPE_TIMELINE_PIPELINE ges_timeline_pipeline_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE</NAME>
#define GES_TIMELINE_PIPELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipeline))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE_CLASS</NAME>
#define GES_TIMELINE_PIPELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipelineClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_PIPELINE</NAME>
#define GES_IS_TIMELINE_PIPELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_PIPELINE_CLASS</NAME>
#define GES_IS_TIMELINE_PIPELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE_GET_CLASS</NAME>
#define GES_TIMELINE_PIPELINE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipelineClass))
</MACRO>
<STRUCT>
<NAME>GESTimelinePipelinePrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GESPipelineFlags</NAME>
typedef enum {
  TIMELINE_MODE_PREVIEW_AUDIO	= 1 << 0,
  TIMELINE_MODE_PREVIEW_VIDEO	= 1 << 1,
  TIMELINE_MODE_PREVIEW		= TIMELINE_MODE_PREVIEW_AUDIO | TIMELINE_MODE_PREVIEW_VIDEO,
  TIMELINE_MODE_RENDER		= 1 << 2,
  TIMELINE_MODE_SMART_RENDER	= 1 << 3
} GESPipelineFlags;
</ENUM>
<STRUCT>
<NAME>GESTimelinePipeline</NAME>
struct _GESTimelinePipeline {
  /*< private >*/
  GstPipeline parent;

  GESTimelinePipelinePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipelineClass</NAME>
struct _GESTimelinePipelineClass {
  /*< private >*/
  GstPipelineClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_pipeline_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_new</NAME>
<RETURNS>GESTimelinePipeline*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_add_timeline</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline * pipeline, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_set_render_settings</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline *pipeline, gchar * output_uri, GstEncodingProfile *profile 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_set_mode</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline *pipeline, GESPipelineFlags mode 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_get_thumbnail_buffer</NAME>
<RETURNS>GstBuffer  *</RETURNS>
GESTimelinePipeline *self, GstCaps *caps 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_get_thumbnail_rgb24</NAME>
<RETURNS>GstBuffer  *</RETURNS>
GESTimelinePipeline *self, gint width, gint height 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_save_thumbnail</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline *self, int width, int height, gchar *format, gchar *location 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_OPERATION</NAME>
#define GES_TYPE_TIMELINE_OPERATION ges_timeline_operation_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OPERATION</NAME>
#define GES_TIMELINE_OPERATION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_OPERATION, GESTimelineOperation))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OPERATION_CLASS</NAME>
#define GES_TIMELINE_OPERATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_OPERATION, GESTimelineOperationClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OPERATION</NAME>
#define GES_IS_TIMELINE_OPERATION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_OPERATION))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OPERATION_CLASS</NAME>
#define GES_IS_TIMELINE_OPERATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_OPERATION))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OPERATION_GET_CLASS</NAME>
#define GES_TIMELINE_OPERATION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_OPERATION, GESTimelineOperationClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineOperationPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOperation</NAME>
struct _GESTimelineOperation {
  /*< private >*/
  GESTimelineObject parent;

  GESTimelineOperationPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineOperationClass</NAME>
struct _GESTimelineOperationClass {
  /*< private >*/
  GESTimelineObjectClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_operation_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_OVERLAY</NAME>
#define GES_TYPE_TIMELINE_OVERLAY ges_timeline_overlay_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OVERLAY</NAME>
#define GES_TIMELINE_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_OVERLAY, GESTimelineOverlay))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OVERLAY_CLASS</NAME>
#define GES_TIMELINE_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_OVERLAY, GESTimelineOverlayClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OVERLAY</NAME>
#define GES_IS_TIMELINE_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OVERLAY_CLASS</NAME>
#define GES_IS_TIMELINE_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OVERLAY_GET_CLASS</NAME>
#define GES_TIMELINE_OVERLAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_OVERLAY, GESTimelineOverlayClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineOverlayPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineOverlay</NAME>
struct _GESTimelineOverlay {
  /*< private >*/
  GESTimelineOperation parent;

  GESTimelineOverlayPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineOverlayClass</NAME>
struct _GESTimelineOverlayClass {
  GESTimelineOperationClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_TYPE_CUSTOM_TIMELINE_SOURCE ges_custom_timeline_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSource))
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE_CLASS</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_IS_CUSTOM_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_CUSTOM_TIMELINE_SOURCE_CLASS</NAME>
#define GES_IS_CUSTOM_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_CUSTOM_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE_GET_CLASS</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSourceClass))
</MACRO>
<STRUCT>
<NAME>GESCustomTimelineSourcePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GESFillTrackObjectUserFunc</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object,
					     GESTrackObject * trobject,
					     GstElement * gnlobj,
					     gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GESCustomTimelineSource</NAME>
struct _GESCustomTimelineSource {
  GESTimelineSource parent;

  /*< private >*/
  GESCustomTimelineSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESCustomTimelineSourceClass</NAME>
struct _GESCustomTimelineSourceClass {
  GESTimelineSourceClass parent_class;

  /*< private >*/
  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_custom_timeline_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_custom_timeline_source_new</NAME>
<RETURNS>GESCustomTimelineSource *</RETURNS>
GESFillTrackObjectUserFunc func, gpointer user_data 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_TITLE_SOURCE</NAME>
#define GES_TYPE_TRACK_TITLE_SOURCE ges_track_title_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_TITLE_SOURCE</NAME>
#define GES_TRACK_TITLE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_TITLE_SOURCE, GESTrackTitleSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TITLE_SOURCE_CLASS</NAME>
#define GES_TRACK_TITLE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_TITLE_SOURCE, GESTrackTitleSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TITLE_SOURCE</NAME>
#define GES_IS_TRACK_TITLE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_TITLE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TITLE_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_TITLE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_TITLE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TITLE_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_TITLE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_TITLE_SOURCE, GESTrackTitleSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackTitleSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTitleSource</NAME>
struct _GESTrackTitleSource {
  GESTrackSource parent;

  /*< private >*/
  gchar         *text;
  gchar         *font_desc;
  GESTextHAlign halign;
  GESTextVAlign valign;
  GstElement    *text_el;
  GstElement    *background_el;

  GESTrackTitleSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackTitleSourceClass</NAME>
struct _GESTrackTitleSourceClass {
  GESTrackSourceClass parent_class;

  /*< private >*/

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_title_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_title_source_set_text</NAME>
<RETURNS>void </RETURNS>
GESTrackTitleSource *self, const gchar *text 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_title_source_set_font_desc</NAME>
<RETURNS>void </RETURNS>
GESTrackTitleSource *self, const gchar *font_desc 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_title_source_set_halignment</NAME>
<RETURNS>void </RETURNS>
GESTrackTitleSource *self, GESTextHAlign halgn 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_title_source_set_valignment</NAME>
<RETURNS>void </RETURNS>
GESTrackTitleSource *self, GESTextVAlign valign 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_title_source_new</NAME>
<RETURNS>GESTrackTitleSource*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_AUDIO_TRANSITION</NAME>
#define GES_TYPE_TRACK_AUDIO_TRANSITION ges_track_audio_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TRANSITION</NAME>
#define GES_TRACK_AUDIO_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_AUDIO_TRANSITION, GESTrackAudioTransition))
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TRANSITION_CLASS</NAME>
#define GES_TRACK_AUDIO_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_AUDIO_TRANSITION, GESTrackAudioTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_AUDIO_TRANSITION</NAME>
#define GES_IS_TRACK_AUDIO_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_AUDIO_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_AUDIO_TRANSITION_CLASS</NAME>
#define GES_IS_TRACK_AUDIO_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_AUDIO_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TRACK_AUDIO_TRANSITION_GET_CLASS</NAME>
#define GES_TRACK_AUDIO_TRANSITION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_AUDIO_TRANSITION, GESTrackAudioTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTrackAudioTransitionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTransition</NAME>
struct _GESTrackAudioTransition {
  GESTrackTransition parent;

  /*< private >*/
  /* these enable volume interpolation. Unlike video, both inputs are adjusted
   * simultaneously */
  GstController                 *a_controller;
  GstInterpolationControlSource *a_control_source;

  GstController                 *b_controller;
  GstInterpolationControlSource *b_control_source;

  GESTrackAudioTransitionPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackAudioTransitionClass</NAME>
struct _GESTrackAudioTransitionClass {
  GESTrackTransitionClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_audio_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_transition_new</NAME>
<RETURNS>GESTrackAudioTransition*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_TITLE_SOURCE</NAME>
#define GES_TYPE_TIMELINE_TITLE_SOURCE ges_timeline_title_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TITLE_SOURCE</NAME>
#define GES_TIMELINE_TITLE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_TITLE_SOURCE, GESTimelineTitleSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TITLE_SOURCE_CLASS</NAME>
#define GES_TIMELINE_TITLE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_TITLE_SOURCE, GESTimelineTitleSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TITLE_SOURCE</NAME>
#define GES_IS_TIMELINE_TITLE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_TITLE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TITLE_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_TITLE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_TITLE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TITLE_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_TITLE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_TITLE_SOURCE, GESTimelineTitleSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineTitleSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTitleSource</NAME>
struct _GESTimelineTitleSource {
  /*< private >*/
  GESTimelineSource parent;

  gboolean mute;
  gchar *text;
  gchar *font_desc;
  GESTextVAlign halign;
  GESTextHAlign valign;

  GESTimelineTitleSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineTitleSourceClass</NAME>
struct _GESTimelineTitleSourceClass {
  /*< private >*/
  GESTimelineSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_title_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_title_source_new</NAME>
<RETURNS>GESTimelineTitleSource*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_KEYFILE_FORMATTER</NAME>
#define GES_TYPE_KEYFILE_FORMATTER ges_keyfile_formatter_get_type()
</MACRO>
<MACRO>
<NAME>GES_KEYFILE_FORMATTER</NAME>
#define GES_KEYFILE_FORMATTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_KEYFILE_FORMATTER, GESKeyfileFormatter))
</MACRO>
<MACRO>
<NAME>GES_KEYFILE_FORMATTER_CLASS</NAME>
#define GES_KEYFILE_FORMATTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_KEYFILE_FORMATTER, GESKeyfileFormatterClass))
</MACRO>
<MACRO>
<NAME>GES_IS_KEYFILE_FORMATTER</NAME>
#define GES_IS_KEYFILE_FORMATTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_KEYFILE_FORMATTER))
</MACRO>
<MACRO>
<NAME>GES_IS_KEYFILE_FORMATTER_CLASS</NAME>
#define GES_IS_KEYFILE_FORMATTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_KEYFILE_FORMATTER))
</MACRO>
<MACRO>
<NAME>GES_KEYFILE_FORMATTER_GET_CLASS</NAME>
#define GES_KEYFILE_FORMATTER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_KEYFILE_FORMATTER, GESKeyfileFormatterClass))
</MACRO>
<STRUCT>
<NAME>GESKeyfileFormatter</NAME>
struct _GESKeyfileFormatter {
  /*< private >*/
  GESFormatter parent;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESKeyfileFormatterClass</NAME>
struct _GESKeyfileFormatterClass {
  /*< private >*/
  GESFormatterClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_keyfile_formatter_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_keyfile_formatter_new</NAME>
<RETURNS>GESKeyfileFormatter *</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_FILESOURCE</NAME>
#define GES_TYPE_TRACK_FILESOURCE ges_track_filesource_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE</NAME>
#define GES_TRACK_FILESOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE_CLASS</NAME>
#define GES_TRACK_FILESOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_FILESOURCE</NAME>
#define GES_IS_TRACK_FILESOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_FILESOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_FILESOURCE_CLASS</NAME>
#define GES_IS_TRACK_FILESOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_FILESOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE_GET_CLASS</NAME>
#define GES_TRACK_FILESOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackFileSourcePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSource</NAME>
struct _GESTrackFileSource {
  /*< private >*/
  GESTrackSource parent;

  gchar *uri;

  GESTrackFileSourcePrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSourceClass</NAME>
struct _GESTrackFileSourceClass {
  /*< private >*/
  GESTrackSourceClass parent_class;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_filesource_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_filesource_new</NAME>
<RETURNS>GESTrackFileSource*</RETURNS>
gchar *uri 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_TEXT_OVERLAY</NAME>
#define GES_TYPE_TRACK_TEXT_OVERLAY ges_track_text_overlay_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_TEXT_OVERLAY</NAME>
#define GES_TRACK_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_TEXT_OVERLAY, GESTrackTextOverlay))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TEXT_OVERLAY_CLASS</NAME>
#define GES_TRACK_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_TEXT_OVERLAY, GESTrackTextOverlayClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TEXT_OVERLAY</NAME>
#define GES_IS_TRACK_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_TEXT_OVERLAY_CLASS</NAME>
#define GES_IS_TRACK_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GES_TRACK_TEXT_OVERLAY_GET_CLASS</NAME>
#define GES_TRACK_TEXT_OVERLAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_TEXT_OVERLAY, GESTrackTextOverlayClass))
</MACRO>
<STRUCT>
<NAME>GESTrackTextOverlayPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackTextOverlay</NAME>
struct _GESTrackTextOverlay {
  /*< private >*/
  GESTrackOperation parent;

  gchar         *text;
  gchar         *font_desc;
  GESTextHAlign halign;
  GESTextVAlign valign;
  GstElement    *text_el;

  GESTrackTextOverlayPrivate *priv;

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GESTrackTextOverlayClass</NAME>
struct _GESTrackTextOverlayClass {
  GESTrackOperationClass parent_class;

  /*< private >*/

  /* Padding for API extension */
  gpointer _ges_reserved[GES_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_text_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_text_overlay_set_text</NAME>
<RETURNS>void </RETURNS>
GESTrackTextOverlay *self, const gchar *text 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_text_overlay_set_font_desc</NAME>
<RETURNS>void </RETURNS>
GESTrackTextOverlay *self, const gchar *font_desc 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_text_overlay_set_halignment</NAME>
<RETURNS>void </RETURNS>
GESTrackTextOverlay *self, GESTextHAlign halgn 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_text_overlay_set_valignment</NAME>
<RETURNS>void </RETURNS>
GESTrackTextOverlay *self, GESTextVAlign valign 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_text_overlay_new</NAME>
<RETURNS>GESTrackTextOverlay*</RETURNS>
void 
</FUNCTION>
