<STRUCT>
<NAME>GESCustomTimelineSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESCustomTimelineSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimeline</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipeline</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipelineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransition</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransitionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrack</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackSourceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSourceClass</NAME>
</STRUCT>
<MACRO>
<NAME>GES_TYPE_TIMELINE_SOURCE</NAME>
#define GES_TYPE_TIMELINE_SOURCE ges_timeline_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE</NAME>
#define GES_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_SOURCE, GESTimelineSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE_CLASS</NAME>
#define GES_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_SOURCE, GESTimelineSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_SOURCE</NAME>
#define GES_IS_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_SOURCE, GESTimelineSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineSource</NAME>
struct _GESTimelineSource {
  GESTimelineObject parent;
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineSourceClass</NAME>
struct _GESTimelineSourceClass {
  GESTimelineObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_source_new</NAME>
<RETURNS>GESTimelineSource*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_TRANSITION</NAME>
#define GES_TYPE_TIMELINE_TRANSITION ges_timeline_transition_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION</NAME>
#define GES_TIMELINE_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransition))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION_CLASS</NAME>
#define GES_TIMELINE_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransitionClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TRANSITION</NAME>
#define GES_IS_TIMELINE_TRANSITION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_TRANSITION_CLASS</NAME>
#define GES_IS_TIMELINE_TRANSITION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_TRANSITION))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_TRANSITION_GET_CLASS</NAME>
#define GES_TIMELINE_TRANSITION_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_TRANSITION, GESTimelineTransitionClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineTransition</NAME>
struct _GESTimelineTransition {
  GESTimelineObject parent;
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineTransitionClass</NAME>
struct _GESTimelineTransitionClass {
  GESTimelineObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_transition_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_transition_new</NAME>
<RETURNS>GESTimelineTransition*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_init</NAME>
<RETURNS>void </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_SOURCE</NAME>
#define GES_TYPE_TRACK_SOURCE ges_track_source_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE</NAME>
#define GES_TRACK_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_SOURCE, GESTrackSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE_CLASS</NAME>
#define GES_TRACK_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_SOURCE, GESTrackSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_SOURCE</NAME>
#define GES_IS_TRACK_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_SOURCE_CLASS</NAME>
#define GES_IS_TRACK_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_SOURCE_GET_CLASS</NAME>
#define GES_TRACK_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_SOURCE, GESTrackSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackSource</NAME>
struct _GESTrackSource {
  GESTrackObject parent;
};
</STRUCT>
<STRUCT>
<NAME>GESTrackSourceClass</NAME>
struct _GESTrackSourceClass {
  GESTrackObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_source_new</NAME>
<RETURNS>GESTrackSource*</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK</NAME>
#define GES_TYPE_TRACK ges_track_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK</NAME>
#define GES_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK, GESTrack))
</MACRO>
<MACRO>
<NAME>GES_TRACK_CLASS</NAME>
#define GES_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK, GESTrackClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK</NAME>
#define GES_IS_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_CLASS</NAME>
#define GES_IS_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK))
</MACRO>
<MACRO>
<NAME>GES_TRACK_GET_CLASS</NAME>
#define GES_TRACK_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK, GESTrackClass))
</MACRO>
<MACRO>
<NAME>GES_TYPE_TRACK_TYPE</NAME>
#define GES_TYPE_TRACK_TYPE (ges_track_type_get_type ())
</MACRO>
<FUNCTION>
<NAME>ges_track_type_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GESTrackType</NAME>
typedef enum {
  GES_TRACK_TYPE_AUDIO	= 0,
  GES_TRACK_TYPE_VIDEO	= 1,
  GES_TRACK_TYPE_TEXT	= 2,
  GES_TRACK_TYPE_CUSTOM	= 3
} GESTrackType;
</ENUM>
<STRUCT>
<NAME>GESTrack</NAME>
struct _GESTrack {
  GstBin parent;

  /*< public >*/ /* READ-ONLY */
  GESTrackType type;

  /*< private >*/
  GESTimeline * timeline;

  GstCaps * caps;

  GstElement * composition;	/* The composition associated with this track */
  GstPad * srcpad;		/* The source GhostPad */
};
</STRUCT>
<STRUCT>
<NAME>GESTrackClass</NAME>
struct _GESTrackClass {
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_new</NAME>
<RETURNS>GESTrack*</RETURNS>
GESTrackType type, GstCaps * caps 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_set_timeline</NAME>
<RETURNS>void </RETURNS>
GESTrack * track, GESTimeline *timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_set_caps</NAME>
<RETURNS>void </RETURNS>
GESTrack * track, const GstCaps * caps 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTrack * track, GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_remove_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTrack * track, GESTrackObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_video_raw_new</NAME>
<RETURNS>GESTrack *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_audio_raw_new</NAME>
<RETURNS>GESTrack *</RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE</NAME>
#define GES_TYPE_TIMELINE ges_timeline_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE</NAME>
#define GES_TIMELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE, GESTimeline))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_CLASS</NAME>
#define GES_TIMELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE, GESTimelineClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE</NAME>
#define GES_IS_TIMELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_CLASS</NAME>
#define GES_IS_TIMELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_GET_CLASS</NAME>
#define GES_TIMELINE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE, GESTimelineClass))
</MACRO>
<STRUCT>
<NAME>GESTimeline</NAME>
struct _GESTimeline {
  GstBin parent;

  /*< private >*/
  GList *layers; /* A list of GESTimelineLayer sorted by priority */
  GList *tracks; /* A list of private track data */
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineClass</NAME>
struct _GESTimelineClass {
  GstBinClass parent_class;

  void (*track_added)	(GESTimeline *timeline, GESTrack * track);
  void (*track_removed)	(GESTimeline *timeline, GESTrack * track);
  void (*layer_added)	(GESTimeline *timeline, GESTimelineLayer *layer);
  void (*layer_removed)	(GESTimeline *timeline, GESTimelineLayer *layer);
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_new</NAME>
<RETURNS>GESTimeline*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_load_from_uri</NAME>
<RETURNS>GESTimeline*</RETURNS>
gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_save</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_add_layer</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTimelineLayer *layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_remove_layer</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTimelineLayer *layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_add_track</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_remove_track</NAME>
<RETURNS>gboolean </RETURNS>
GESTimeline *timeline, GESTrack *track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_get_track_for_pad</NAME>
<RETURNS>GESTrack *</RETURNS>
GESTimeline *timeline, GstPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_get_tracks</NAME>
<RETURNS>GList *</RETURNS>
GESTimeline *timeline 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_OBJECT</NAME>
#define GES_TYPE_TIMELINE_OBJECT ges_timeline_object_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT</NAME>
#define GES_TIMELINE_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_OBJECT, GESTimelineObject))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_CLASS</NAME>
#define GES_TIMELINE_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_OBJECT, GESTimelineObjectClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OBJECT</NAME>
#define GES_IS_TIMELINE_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_OBJECT_CLASS</NAME>
#define GES_IS_TIMELINE_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_GET_CLASS</NAME>
#define GES_TIMELINE_OBJECT_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_OBJECT, GESTimelineObjectClass))
</MACRO>
<USER_FUNCTION>
<NAME>FillTrackObjectFunc</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object,
					 GESTrackObject * trobject,
					 GstElement * gnlobj
</USER_FUNCTION>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_START</NAME>
#define GES_TIMELINE_OBJECT_START(obj) (((GESTimelineObject*)obj)->start)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_INPOINT</NAME>
#define GES_TIMELINE_OBJECT_INPOINT(obj) (((GESTimelineObject*)obj)->inpoint)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_DURATION</NAME>
#define GES_TIMELINE_OBJECT_DURATION(obj) (((GESTimelineObject*)obj)->duration)
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_OBJECT_PRIORITY</NAME>
#define GES_TIMELINE_OBJECT_PRIORITY(obj) (((GESTimelineObject*)obj)->priority)
</MACRO>
<STRUCT>
<NAME>GESTimelineObject</NAME>
struct _GESTimelineObject {
  GObject parent;

  /*< public >*/
  GESTimelineLayer * layer;

  /*< private >*/
  GList *trackobjects;	/* A list of TrackObject controlled by this TimelineObject */

  /* start, inpoint, duration and fullduration are in nanoseconds */
  guint64 start;	/* position (in time) of the object in the layer */
  guint64 inpoint;	/* in-point */
  guint64 duration;	/* duration of the object used in the layer */
  guint32 priority;	/* priority of the object in the layer (0:top priority) */

  guint64 fullduration; /* Full usable duration of the object (-1: no duration) */
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineObjectClass</NAME>
struct _GESTimelineObjectClass {
  GObjectClass parent_class;

  GESTrackObject*	(*create_track_object)	(GESTimelineObject * object,
						 GESTrack * track);
  /* FIXME : might need a release_track_object */
  FillTrackObjectFunc	fill_track_object;
  gboolean need_fill_track;
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_start</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 start 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_inpoint</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 inpoint 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_duration</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint64 duration 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_priority</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, guint priority 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_set_layer</NAME>
<RETURNS>void </RETURNS>
GESTimelineObject * object, GESTimelineLayer * layer 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_create_track_object</NAME>
<RETURNS>GESTrackObject  *</RETURNS>
GESTimelineObject * object, GESTrack * track 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_release_track_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object, GESTrackObject * trackobject 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_fill_track_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object, GESTrackObject * trackobj, GstElement * gnlobj 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_object_find_track_object</NAME>
<RETURNS>GESTrackObject  *</RETURNS>
GESTimelineObject * object, GESTrack * track 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_TYPE_SIMPLE_TIMELINE_LAYER ges_simple_timeline_layer_get_type()
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_SIMPLE_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayer))
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER_CLASS</NAME>
#define GES_SIMPLE_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayerClass))
</MACRO>
<MACRO>
<NAME>GES_IS_SIMPLE_TIMELINE_LAYER</NAME>
#define GES_IS_SIMPLE_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_IS_SIMPLE_TIMELINE_LAYER_CLASS</NAME>
#define GES_IS_SIMPLE_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_SIMPLE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_SIMPLE_TIMELINE_LAYER_GET_CLASS</NAME>
#define GES_SIMPLE_TIMELINE_LAYER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_SIMPLE_TIMELINE_LAYER, GESSimpleTimelineLayerClass))
</MACRO>
<STRUCT>
<NAME>GESSimpleTimelineLayer</NAME>
struct _GESSimpleTimelineLayer {
  GESTimelineLayer parent;

  /*< private >*/
  /* Sorted list of objects */
  GList *objects;

  gboolean adding_object;
};
</STRUCT>
<STRUCT>
<NAME>GESSimpleTimelineLayerClass</NAME>
struct _GESSimpleTimelineLayerClass {
  GESTimelineLayerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_simple_timeline_layer_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_new</NAME>
<RETURNS>GESSimpleTimelineLayer*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESSimpleTimelineLayer *layer, GESTimelineObject *object, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ges_simple_timeline_layer_move_object</NAME>
<RETURNS>gboolean </RETURNS>
GESSimpleTimelineLayer *layer, GESTimelineObject *object, gint newposition 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_LAYER</NAME>
#define GES_TYPE_TIMELINE_LAYER ges_timeline_layer_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER</NAME>
#define GES_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_LAYER, GESTimelineLayer))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER_CLASS</NAME>
#define GES_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_LAYER, GESTimelineLayerClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_LAYER</NAME>
#define GES_IS_TIMELINE_LAYER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_LAYER_CLASS</NAME>
#define GES_IS_TIMELINE_LAYER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_LAYER))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_LAYER_GET_CLASS</NAME>
#define GES_TIMELINE_LAYER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_LAYER, GESTimelineLayerClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineLayer</NAME>
struct _GESTimelineLayer {
  GObject parent;

  GESTimeline *timeline;	/* The timeline where this layer is being used
				 */

  GSList * objects_start;	/* The TimelineObjects sorted by start and
				 * priority */

  guint32 priority;		/* The priority of the layer within the 
				 * containing timeline */

  /*< private >*/
  guint32 min_gnl_priority, max_gnl_priority;
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineLayerClass</NAME>
struct _GESTimelineLayerClass {
  GObjectClass parent_class;

  /*< signals >*/
  void	(*object_added)		(GESTimelineLayer * layer, GESTimelineObject * object);
  void	(*object_removed)	(GESTimelineLayer * layer, GESTimelineObject * object);
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_layer_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_new</NAME>
<RETURNS>GESTimelineLayer*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_set_timeline</NAME>
<RETURNS>void </RETURNS>
GESTimelineLayer * layer, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_add_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineLayer * layer, GESTimelineObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_remove_object</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineLayer * layer, GESTimelineObject * object 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_layer_set_priority</NAME>
<RETURNS>void </RETURNS>
GESTimelineLayer * layer, guint priority 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_FILE_SOURCE</NAME>
#define GES_TYPE_TIMELINE_FILE_SOURCE ges_tl_filesource_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE</NAME>
#define GES_TIMELINE_FILE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSource))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE_CLASS</NAME>
#define GES_TIMELINE_FILE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_FILE_SOURCE</NAME>
#define GES_IS_TIMELINE_FILE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_FILE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_FILE_SOURCE_CLASS</NAME>
#define GES_IS_TIMELINE_FILE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_FILE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_FILE_SOURCE_GET_CLASS</NAME>
#define GES_TIMELINE_FILE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_FILE_SOURCE, GESTimelineFileSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTimelineFileSource</NAME>
struct _GESTimelineFileSource {
  GESTimelineSource parent;

  /*< private >*/
  gchar *uri;

  guint64 maxduration;

  gboolean mute;
};
</STRUCT>
<STRUCT>
<NAME>GESTimelineFileSourceClass</NAME>
struct _GESTimelineFileSourceClass {
  GESTimelineSourceClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_tl_filesource_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_filesource_new</NAME>
<RETURNS>GESTimelineFileSource*</RETURNS>
gchar *uri 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_OBJECT</NAME>
#define GES_TYPE_TRACK_OBJECT ges_track_object_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT</NAME>
#define GES_TRACK_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_OBJECT, GESTrackObject))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_CLASS</NAME>
#define GES_TRACK_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_OBJECT, GESTrackObjectClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OBJECT</NAME>
#define GES_IS_TRACK_OBJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_OBJECT_CLASS</NAME>
#define GES_IS_TRACK_OBJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_OBJECT))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_GET_CLASS</NAME>
#define GES_TRACK_OBJECT_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_OBJECT, GESTrackObjectClass))
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_START</NAME>
#define GES_TRACK_OBJECT_START(obj) (((GESTrackObject*)obj)->start)
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_INPOINT</NAME>
#define GES_TRACK_OBJECT_INPOINT(obj) (((GESTrackObject*)obj)->inpoint)
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_DURATION</NAME>
#define GES_TRACK_OBJECT_DURATION(obj) (((GESTrackObject*)obj)->duration)
</MACRO>
<MACRO>
<NAME>GES_TRACK_OBJECT_PRIORITY</NAME>
#define GES_TRACK_OBJECT_PRIORITY(obj) (((GESTrackObject*)obj)->priority)
</MACRO>
<STRUCT>
<NAME>GESTrackObject</NAME>
struct _GESTrackObject {
  GObject parent;

  /*< public >*/
  GESTimelineObject *timelineobj;
  GESTrack *track;

  gboolean valid;

  /* Cached values of the gnlobject properties */
  guint64 start;
  guint64 inpoint;
  guint64 duration;
  guint32 priority;
  gboolean active;

  /*< private >*/
  /* These fields are only used before the gnlobject is available */
  guint64 pending_start;
  guint64 pending_inpoint;
  guint64 pending_duration;
  guint32 pending_priority;
  gboolean pending_active;

  GstElement *gnlobject;
};
</STRUCT>
<STRUCT>
<NAME>GESTrackObjectClass</NAME>
struct _GESTrackObjectClass {
  GObjectClass parent_class;

  /*< private >*/
  /* signals */
  void	(*changed)	(GESTrackObject * object);

  /*< public >*/
  /* virtual methods for subclasses */
  gboolean (*create_gnl_object) (GESTrackObject * object);
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_object_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_track</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, GESTrack * track 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_timeline_object</NAME>
<RETURNS>void </RETURNS>
GESTrackObject * object, GESTimelineObject * tlobject 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_start_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 start 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_inpoint_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 inpoint 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_duration_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint64 duration 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_priority_internal</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, guint32 priority 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_object_set_active</NAME>
<RETURNS>gboolean </RETURNS>
GESTrackObject * object, gboolean active 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TIMELINE_PIPELINE</NAME>
#define GES_TYPE_TIMELINE_PIPELINE ges_timeline_pipeline_get_type()
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE</NAME>
#define GES_TIMELINE_PIPELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipeline))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE_CLASS</NAME>
#define GES_TIMELINE_PIPELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipelineClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_PIPELINE</NAME>
#define GES_IS_TIMELINE_PIPELINE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TIMELINE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GES_IS_TIMELINE_PIPELINE_CLASS</NAME>
#define GES_IS_TIMELINE_PIPELINE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TIMELINE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GES_TIMELINE_PIPELINE_GET_CLASS</NAME>
#define GES_TIMELINE_PIPELINE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TIMELINE_PIPELINE, GESTimelinePipelineClass))
</MACRO>
<ENUM>
<NAME>GESPipelineFlags</NAME>
typedef enum {
  TIMELINE_MODE_PREVIEW_AUDIO	= 1 << 0,
  TIMELINE_MODE_PREVIEW_VIDEO	= 1 << 1,
  TIMELINE_MODE_PREVIEW		= TIMELINE_MODE_PREVIEW_AUDIO | TIMELINE_MODE_PREVIEW_VIDEO,
  TIMELINE_MODE_RENDER		= 1 << 2,
  TIMELINE_MODE_SMART_RENDER	= 1 << 3
} GESPipelineFlags;
</ENUM>
<STRUCT>
<NAME>GESTimelinePipeline</NAME>
struct _GESTimelinePipeline {
  GstPipeline parent;

  /* <private> */
  GESTimeline * timeline;
  GstElement * playsink;
  GstElement * encodebin;
  /* Note : urisink is only created when a URI has been provided */
  GstElement * urisink;

  GESPipelineFlags mode;

  GList *chains;

  GstEncodingProfile *profile;
};
</STRUCT>
<STRUCT>
<NAME>GESTimelinePipelineClass</NAME>
struct _GESTimelinePipelineClass {
  GstPipelineClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_timeline_pipeline_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_new</NAME>
<RETURNS>GESTimelinePipeline*</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_add_timeline</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline * pipeline, GESTimeline * timeline 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_set_render_settings</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline *pipeline, gchar * output_uri, GstEncodingProfile *profile 
</FUNCTION>
<FUNCTION>
<NAME>ges_timeline_pipeline_set_mode</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelinePipeline *pipeline, GESPipelineFlags mode 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_TYPE_CUSTOM_TIMELINE_SOURCE ges_cust_timeline_src_get_type()
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSource))
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE_CLASS</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_CUSTOM_TIMELINE_SOURCE</NAME>
#define GES_IS_CUSTOM_TIMELINE_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_CUSTOM_TIMELINE_SOURCE_CLASS</NAME>
#define GES_IS_CUSTOM_TIMELINE_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_CUSTOM_TIMELINE_SOURCE))
</MACRO>
<MACRO>
<NAME>GES_CUSTOM_TIMELINE_SOURCE_GET_CLASS</NAME>
#define GES_CUSTOM_TIMELINE_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_CUSTOM_TIMELINE_SOURCE, GESCustomTimelineSourceClass))
</MACRO>
<USER_FUNCTION>
<NAME>FillTrackObjectUserFunc</NAME>
<RETURNS>gboolean </RETURNS>
GESTimelineObject * object,
					     GESTrackObject * trobject,
					     GstElement * gnlobj,
					     gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GESCustomTimelineSource</NAME>
struct _GESCustomTimelineSource {
  GESTimelineSource parent;

  FillTrackObjectUserFunc filltrackobjectfunc;
  gpointer user_data;
};
</STRUCT>
<STRUCT>
<NAME>GESCustomTimelineSourceClass</NAME>
struct _GESCustomTimelineSourceClass {
  GESTimelineSourceClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_cust_timeline_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_custom_timeline_source_new</NAME>
<RETURNS>GESCustomTimelineSource *</RETURNS>
FillTrackObjectUserFunc func, gpointer user_data 
</FUNCTION>
<MACRO>
<NAME>GES_TYPE_TRACK_FILESOURCE</NAME>
#define GES_TYPE_TRACK_FILESOURCE ges_track_filesource_get_type()
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE</NAME>
#define GES_TRACK_FILESOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSource))
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE_CLASS</NAME>
#define GES_TRACK_FILESOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSourceClass))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_FILESOURCE</NAME>
#define GES_IS_TRACK_FILESOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GES_TYPE_TRACK_FILESOURCE))
</MACRO>
<MACRO>
<NAME>GES_IS_TRACK_FILESOURCE_CLASS</NAME>
#define GES_IS_TRACK_FILESOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GES_TYPE_TRACK_FILESOURCE))
</MACRO>
<MACRO>
<NAME>GES_TRACK_FILESOURCE_GET_CLASS</NAME>
#define GES_TRACK_FILESOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GES_TYPE_TRACK_FILESOURCE, GESTrackFileSourceClass))
</MACRO>
<STRUCT>
<NAME>GESTrackFileSource</NAME>
struct _GESTrackFileSource {
  GESTrackObject parent;

  /*< public >*/
  gchar *uri;
};
</STRUCT>
<STRUCT>
<NAME>GESTrackFileSourceClass</NAME>
struct _GESTrackFileSourceClass {
  GESTrackObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>ges_track_filesource_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ges_track_filesource_new</NAME>
<RETURNS>GESTrackFileSource*</RETURNS>
gchar *uri 
</FUNCTION>
