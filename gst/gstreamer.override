/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2002 David I. Lehn
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: David I. Lehn <dlehn@vt.edu>
 */
%%
headers
#include <Python.h>

#include "pygobject.h"
#include <gst/gst.h>

#include "gstreamer-fixes.h"

typedef struct {
	PyGObject *pad;
	PyObject *connect_function;
	PyObject *chain_function;
} PyGstPadPrivate;

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
	return (PyGstPadPrivate*)gst_pad_get_element_private(pad);
}
	
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
	PyGstPadPrivate *private;
	GstPad *gpad;

	gpad = (GstPad*)pygobject_get(pad);
	private = (PyGstPadPrivate*)gst_pad_get_element_private(gpad);
	if (private == NULL) {
		/* FIXME need to free this somewhere */
		private = g_new0(PyGstPadPrivate, 1);
		Py_INCREF(pad);
		private->pad = pad;
		gst_pad_set_element_private(gpad, private);
	}
	return private;
}
	
%%
modulename gstreamer
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
 _*
 gstreamer_*init
 *_get_type
%%
override gst_pad_set_connect_function kwargs

static GstPadConnectReturn
call_connect_function (GstPad *pad, GstCaps *caps)
{
	PyObject *function;
	PyObject *retval;
	
	function = pad_private(pad)->connect_function;
	
	retval = (PyObject*)PyObject_CallFunction (function,
			"OO",
			pad_private(pad)->pad,
    			pyg_boxed_new(GST_TYPE_CAPS, caps, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
		return GST_PAD_CONNECT_REFUSED;
	}

	return PyInt_AsLong(retval);
}

static PyObject*
_wrap_gst_pad_set_connect_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	static char *kwlist[] = { "connect_function", NULL };
	PyObject *connect_function;
	GstPad *pad;
	
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
	                                 "O:GstPad.set_connect_funcion",
					 kwlist,
					 &connect_function)) {
		return NULL;
	}
	
	if (!PyCallable_Check(connect_function)) {
		PyErr_SetString(PyExc_TypeError, "connect_function not callable");
		return NULL;
	}
	
	Py_INCREF(connect_function);
	py_pad_private(self)->connect_function = connect_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_connect_function(pad, call_connect_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_chain_function kwargs

static void
call_chain_function(GstPad *pad, GstBuffer *buf)
{
	PyObject *function;
	
	function = pad_private(pad)->chain_function;
	
	PyObject_CallFunction (function,
			"OO", 
			pad_private(pad)->pad,
    			pyg_boxed_new(GST_TYPE_BUFFER, buf, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
		return;
	}
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "chain_function", NULL };
	PyObject *chain_function;
	GstPad *pad;
	
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
	                                 "O:GstPad.set_chain_funcion",
					 kwlist,
					 &chain_function)) {
		return NULL;
	}
	
	if (!PyCallable_Check(chain_function)) {
		PyErr_SetString(PyExc_TypeError, "chain_function not callable");
		return NULL;
	}
	
	Py_INCREF(chain_function);
	py_pad_private(self)->chain_function = chain_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_chain_function(pad, call_chain_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_buffer_get_data

static PyObject*
_wrap_gst_buffer_get_data(PyObject *self)
{
	GstBuffer *buf;
	
	buf = pyg_boxed_get(self, GstBuffer);

	return PyString_FromStringAndSize(
			GST_BUFFER_DATA(buf),
			GST_BUFFER_SIZE(buf));
}
%%
override gst_buffer_set_data kwargs

static PyObject*
_wrap_gst_buffer_set_data(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"data", NULL};
	PyObject *data;
	GstBuffer *buf;
	
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstBuffer:set_data", kwlist, &data)) {
		return NULL;
	}
	if (!PyString_Check(data)) {
		PyErr_SetString(PyExc_TypeError, "data should be a string");
		return NULL;
	}
	buf = pyg_boxed_get(self, GstBuffer);
	if (GST_BUFFER_FLAGS(buf) & GST_BUFFER_READONLY) {
		PyErr_SetString(PyExc_TypeError, "set_data can't use a READONLY buffer");
		return NULL;
	}
	GST_BUFFER_SIZE(buf) = PyString_Size(data);
	GST_BUFFER_DATA(buf) = g_new0(char, GST_BUFFER_SIZE(buf));

	memcpy(GST_BUFFER_DATA(buf),
			PyString_AsString(data),
			PyString_Size(data));

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_bin_iterate

static PyObject *
_wrap_gst_bin_iterate(PyGObject *self)
{
    int ret;

    pyg_unblock_threads();
    ret = gst_bin_iterate(GST_BIN(self->obj));
    pyg_block_threads();
    return PyInt_FromLong(ret);
}
