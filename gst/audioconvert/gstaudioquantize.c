/* GStreamer
 * Copyright (C) 2007 Sebastian Dr√∂ge <slomo@circular-chaos.org>
 *
 * gstaudioquantize.c: quantizes audio to the target format and optionally
 *                     applies dithering and noise shaping.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

/*
 * FIXME: When doing dithering with int as intermediate format
 *        one gets audible harmonics while the noise floor is
 *        constant for double as intermediate format!
 */

/* TODO: - Maybe drop 5-pole noise shaping and use coefficients
 *         generated by dmaker
 *         http://shibatch.sf.net
 */

#include <gst/gst.h>
#include <string.h>
#include <math.h>
#include "gstaudioconvertorc.h"
#include "gstaudioquantize.h"

#include "gstfastrandom.h"

typedef void (*QuantizeFunc) (GstAudioQuantize * quant, gpointer src,
    gpointer dst, gint count);

struct _GstAudioQuantize
{
  GstAudioDitherMethod dither;
  GstAudioNoiseShapingMethod ns;
  GstAudioQuantizeFlags flags;
  GstAudioFormat format;
  guint channels;
  guint quantizer;

  /* last random number generated per channel for hifreq TPDF dither */
  gpointer last_random;
  /* contains the past quantization errors, error[out_channels][count] */
  gdouble *error_buf;

  QuantizeFunc quantize;
};

#define MAKE_QUANTIZE_FUNC_NAME(name)                                   \
gst_audio_quantize_quantize_##name

#define ADDSS(res,val) \
        if (val > 0 && res > 0 && G_MAXINT32 - res <= val)              \
          res = G_MAXINT32;                                             \
        else if (val < 0 && res < 0 && G_MININT32 - res >= val)         \
          res = G_MININT32;                                             \
        else                                                            \
          res += val;

/* Quantize functions for gint32 as intermediate format */

#define MAKE_QUANTIZE_FUNC_I(name, DITHER_INIT_FUNC, ADD_DITHER_FUNC,   \
                             ROUND_FUNC)                                \
static void                                                             \
MAKE_QUANTIZE_FUNC_NAME (name) (GstAudioQuantize *quant, gint32 *src,   \
                                gint32 *dst, gint count)                \
{                                                                       \
  gint scale = quant->quantizer;                                        \
  gint channels = quant->channels;                                      \
  gint chan_pos;                                                        \
                                                                        \
  if (scale > 0) {                                                      \
    gint32 tmp;                                                         \
    guint32 mask = 0xffffffff & (0xffffffff << scale);                  \
    guint32 bias = 1U << (scale - 1);                                   \
    DITHER_INIT_FUNC()                                                  \
                                                                        \
    for (;count;count--) {                                              \
      for (chan_pos = 0; chan_pos < channels; chan_pos++) {             \
        tmp = *src++;                                                   \
        ADD_DITHER_FUNC()                                               \
        ROUND_FUNC()                                                    \
        *dst = tmp & mask;                                              \
        dst++;                                                          \
      }                                                                 \
    }                                                                   \
  } else {                                                              \
    memcpy (dst, src, count * channels * 4);                            \
  }                                                                     \
}


/* Quantize functions for gdouble as intermediate format with
 * int as target */

#define MAKE_QUANTIZE_FUNC_F(name, DITHER_INIT_FUNC, NS_INIT_FUNC,      \
                             ADD_NS_FUNC, ADD_DITHER_FUNC,              \
                             UPDATE_ERROR_FUNC)                         \
static void                                                             \
MAKE_QUANTIZE_FUNC_NAME (name) (GstAudioQuantize *quant, gdouble *src,  \
                                gint32 *dst, gint count)                \
{                                                                       \
  gint scale = quant->quantizer;                                        \
  gint channels = quant->channels;                                      \
  gint chan_pos;                                                        \
  gdouble tmp, d, factor = (1U<<(32-scale-1));                          \
                                                                        \
  if (scale > 0) {                                                      \
    DITHER_INIT_FUNC()                                                  \
    NS_INIT_FUNC()                                                      \
                                                                        \
    for (;count;count--) {                                              \
      for (chan_pos = 0; chan_pos < channels; chan_pos++) {             \
        tmp = *src++;                                                   \
        ADD_NS_FUNC()                                                   \
        ADD_DITHER_FUNC()                                               \
        tmp = floor(tmp * factor);                                      \
        d = CLAMP (tmp, -factor, factor - 1);                           \
        UPDATE_ERROR_FUNC()                                             \
        *dst++ = ((gint32)d) << scale;                                  \
      }                                                                 \
    }                                                                   \
  } else {                                                              \
    audio_convert_orc_double_to_s32 (dst, src, count * channels);       \
  }                                                                     \
}

/* Rounding functions for int as intermediate format, only used when
 * not using dithering. With dithering we include this offset in our
 * dither noise instead. */

#define ROUND()                                                         \
        if (tmp > 0 && G_MAXINT32 - tmp <= bias)                        \
          tmp = G_MAXINT32;                                             \
        else                                                            \
          tmp += bias;


#define NONE_FUNC()

/* Dithering definitions
 * See http://en.wikipedia.org/wiki/Dithering or
 * http://www.users.qwest.net/~volt42/cadenzarecording/DitherExplained.pdf for explainations.
 *
 * We already add the rounding offset to the dither noise here
 * to have only one overflow check instead of two. */

#define INIT_DITHER_RPDF_I()                                            \
  gint32 rand;                                                          \
  gint32 dither = (1<<(scale));

/* Assuming dither == 2^n,
 * returns one of 2^(n+1) possible random values:
 * -dither <= retval < dither */
#define RANDOM_INT_DITHER(dither)                                       \
  (- dither + (gst_fast_random_int32 () & ((dither << 1) - 1)))

#define ADD_DITHER_RPDF_I()                                             \
        rand = bias + RANDOM_INT_DITHER(dither);                        \
        ADDSS (tmp, rand);

#define INIT_DITHER_RPDF_F()                                            \
  gdouble dither = 1.0/(1U<<(32 - scale - 1));

#define ADD_DITHER_RPDF_F()                                             \
        tmp += gst_fast_random_double_range (- dither, dither);

#define INIT_DITHER_TPDF_I()                                            \
  gint32 rand;                                                          \
  gint32 dither = (1<<(scale - 1));

#define ADD_DITHER_TPDF_I()                                             \
        rand = bias + RANDOM_INT_DITHER(dither)                         \
                    + RANDOM_INT_DITHER(dither);                        \
        ADDSS (tmp, rand);

#define INIT_DITHER_TPDF_F()                                            \
  gdouble dither = 1.0/(1U<<(32 - scale));

#define ADD_DITHER_TPDF_F()                                             \
        tmp += gst_fast_random_double_range (- dither, dither)          \
               + gst_fast_random_double_range (- dither, dither);

#define INIT_DITHER_TPDF_HF_I()                                         \
  gint32 rand;                                                          \
  gint32 dither = (1<<(scale-1));                                       \
  gint32 *last_random = (gint32 *) quant->last_random, tmp_rand;

#define ADD_DITHER_TPDF_HF_I()                                          \
        tmp_rand = RANDOM_INT_DITHER(dither);                           \
        rand = bias + tmp_rand - last_random[chan_pos];                 \
        last_random[chan_pos] = tmp_rand;                               \
        ADDSS (tmp, rand);

/* Like TPDF dither but the dither noise is oriented more to the
 * higher frequencies */

#define INIT_DITHER_TPDF_HF_F()                                         \
  gdouble rand;                                                         \
  gdouble dither = 1.0/(1U<<(32 - scale));                              \
  gdouble *last_random = (gdouble *) quant->last_random, tmp_rand;

#define ADD_DITHER_TPDF_HF_F()                                          \
        tmp_rand = gst_fast_random_double_range (- dither, dither);     \
        rand = tmp_rand - last_random[chan_pos];                        \
        last_random[chan_pos] = tmp_rand;                               \
        tmp += rand;

/* Noise shaping definitions.
 * See http://en.wikipedia.org/wiki/Noise_shaping for explanations. */


/* Simple error feedback: Just accumulate the dithering and quantization
 * error and remove it from each sample. */

#define INIT_NS_ERROR_FEEDBACK()                                        \
  gdouble orig;                                                         \
  gdouble *errors = quant->error_buf;

#define ADD_NS_ERROR_FEEDBACK()                                         \
        orig = tmp;                                                     \
        tmp -= errors[chan_pos];

#define UPDATE_ERROR_ERROR_FEEDBACK()                                   \
        errors[chan_pos] += (d)/factor - orig;

/* Same as error feedback but also add 1/2 of the previous error value.
 * This moves the noise a bit more into the higher frequencies. */

#define INIT_NS_SIMPLE()                                                \
  gdouble orig;                                                         \
  gdouble *errors = quant->error_buf, cur_error;

#define ADD_NS_SIMPLE()                                                 \
        cur_error = errors[chan_pos*2] - 0.5 * errors[chan_pos*2 + 1];  \
        tmp -= cur_error;                                               \
        orig = tmp;

#define UPDATE_ERROR_SIMPLE()                                           \
        errors[chan_pos*2 + 1] = errors[chan_pos*2];                    \
        errors[chan_pos*2] = (d)/factor - orig;


/* Noise shaping coefficients from[1], moves most power of the
 * error noise into inaudible frequency ranges.
 *
 * [1]
 * "Minimally Audible Noise Shaping", Stanley P. Lipshitz,
 * John Vanderkooy, and Robert A. Wannamaker,
 * J. Audio Eng. Soc., Vol. 39, No. 11, November 1991. */

static const gdouble ns_medium_coeffs[] = {
  2.033, -2.165, 1.959, -1.590, 0.6149
};

#define INIT_NS_MEDIUM()                                                \
  gdouble orig;                                                         \
  gdouble *errors = quant->error_buf, cur_error;                        \
  int j;

#define ADD_NS_MEDIUM()                                                 \
        cur_error = 0.0;                                                \
        for (j = 0; j < 5; j++)                                         \
          cur_error += errors[chan_pos*5 + j] * ns_medium_coeffs[j];    \
        tmp -= cur_error;                                               \
        orig = tmp;

#define UPDATE_ERROR_MEDIUM()                                           \
        for (j = 4; j > 0; j--)                                         \
          errors[chan_pos*5 + j] = errors[chan_pos*5 + j-1];            \
        errors[chan_pos*5] = (d)/factor - orig;

/* Noise shaping coefficients by David Schleef, moves most power of the
 * error noise into inaudible frequency ranges */

static const gdouble ns_high_coeffs[] = {
  2.08484, -2.92975, 3.27918, -3.31399, 2.61339, -1.72008, 0.876066, -0.340122
};

#define INIT_NS_HIGH()                                                  \
  gdouble orig;                                                         \
  gdouble *errors = quant->error_buf, cur_error;                        \
  int j;

#define ADD_NS_HIGH()                                                   \
        cur_error = 0.0;                                                \
        for (j = 0; j < 8; j++)                                         \
          cur_error += errors[chan_pos*8 + j] * ns_high_coeffs[j];      \
        tmp -= cur_error;                                               \
        orig = tmp;

#define UPDATE_ERROR_HIGH()                                             \
        for (j = 7; j > 0; j--)                                         \
          errors[chan_pos*8 + j] = errors[chan_pos*8 + j-1];            \
        errors[chan_pos*8] = (d)/factor - orig;


MAKE_QUANTIZE_FUNC_I (int_none_none, NONE_FUNC, NONE_FUNC, ROUND);
MAKE_QUANTIZE_FUNC_I (int_rpdf_none, INIT_DITHER_RPDF_I, ADD_DITHER_RPDF_I,
    NONE_FUNC);
MAKE_QUANTIZE_FUNC_I (int_tpdf_none, INIT_DITHER_TPDF_I, ADD_DITHER_TPDF_I,
    NONE_FUNC);
MAKE_QUANTIZE_FUNC_I (int_tpdf_hf_none, INIT_DITHER_TPDF_HF_I,
    ADD_DITHER_TPDF_HF_I, NONE_FUNC);

MAKE_QUANTIZE_FUNC_F (float_none_none, NONE_FUNC,
    NONE_FUNC, NONE_FUNC, NONE_FUNC, NONE_FUNC);
MAKE_QUANTIZE_FUNC_F (float_none_error_feedback, NONE_FUNC,
    INIT_NS_ERROR_FEEDBACK, ADD_NS_ERROR_FEEDBACK, NONE_FUNC,
    UPDATE_ERROR_ERROR_FEEDBACK);
MAKE_QUANTIZE_FUNC_F (float_none_simple, NONE_FUNC, INIT_NS_SIMPLE,
    ADD_NS_SIMPLE, NONE_FUNC, UPDATE_ERROR_SIMPLE);
MAKE_QUANTIZE_FUNC_F (float_none_medium, NONE_FUNC, INIT_NS_MEDIUM,
    ADD_NS_MEDIUM, NONE_FUNC, UPDATE_ERROR_MEDIUM);
MAKE_QUANTIZE_FUNC_F (float_none_high, NONE_FUNC, INIT_NS_HIGH, ADD_NS_HIGH,
    NONE_FUNC, UPDATE_ERROR_HIGH);

MAKE_QUANTIZE_FUNC_F (float_rpdf_none, INIT_DITHER_RPDF_F,
    NONE_FUNC, NONE_FUNC, ADD_DITHER_RPDF_F, NONE_FUNC);
MAKE_QUANTIZE_FUNC_F (float_rpdf_error_feedback, INIT_DITHER_RPDF_F,
    INIT_NS_ERROR_FEEDBACK, ADD_NS_ERROR_FEEDBACK, ADD_DITHER_RPDF_F,
    UPDATE_ERROR_ERROR_FEEDBACK);
MAKE_QUANTIZE_FUNC_F (float_rpdf_simple, INIT_DITHER_RPDF_F, INIT_NS_SIMPLE,
    ADD_NS_SIMPLE, ADD_DITHER_RPDF_F, UPDATE_ERROR_SIMPLE);
MAKE_QUANTIZE_FUNC_F (float_rpdf_medium, INIT_DITHER_RPDF_F, INIT_NS_MEDIUM,
    ADD_NS_MEDIUM, ADD_DITHER_RPDF_F, UPDATE_ERROR_MEDIUM);
MAKE_QUANTIZE_FUNC_F (float_rpdf_high, INIT_DITHER_RPDF_F, INIT_NS_HIGH,
    ADD_NS_HIGH, ADD_DITHER_RPDF_F, UPDATE_ERROR_HIGH);

MAKE_QUANTIZE_FUNC_F (float_tpdf_none, INIT_DITHER_TPDF_F,
    NONE_FUNC, NONE_FUNC, ADD_DITHER_TPDF_F, NONE_FUNC);
MAKE_QUANTIZE_FUNC_F (float_tpdf_error_feedback, INIT_DITHER_TPDF_F,
    INIT_NS_ERROR_FEEDBACK, ADD_NS_ERROR_FEEDBACK, ADD_DITHER_TPDF_F,
    UPDATE_ERROR_ERROR_FEEDBACK);
MAKE_QUANTIZE_FUNC_F (float_tpdf_simple, INIT_DITHER_TPDF_F, INIT_NS_SIMPLE,
    ADD_NS_SIMPLE, ADD_DITHER_TPDF_F, UPDATE_ERROR_SIMPLE);
MAKE_QUANTIZE_FUNC_F (float_tpdf_medium, INIT_DITHER_TPDF_F, INIT_NS_MEDIUM,
    ADD_NS_MEDIUM, ADD_DITHER_TPDF_F, UPDATE_ERROR_MEDIUM);
MAKE_QUANTIZE_FUNC_F (float_tpdf_high, INIT_DITHER_TPDF_F, INIT_NS_HIGH,
    ADD_NS_HIGH, ADD_DITHER_TPDF_F, UPDATE_ERROR_HIGH);

MAKE_QUANTIZE_FUNC_F (float_tpdf_hf_none, INIT_DITHER_TPDF_HF_F,
    NONE_FUNC, NONE_FUNC, ADD_DITHER_TPDF_HF_F, NONE_FUNC);
MAKE_QUANTIZE_FUNC_F (float_tpdf_hf_error_feedback, INIT_DITHER_TPDF_HF_F,
    INIT_NS_ERROR_FEEDBACK, ADD_NS_ERROR_FEEDBACK, ADD_DITHER_TPDF_HF_F,
    UPDATE_ERROR_ERROR_FEEDBACK);
MAKE_QUANTIZE_FUNC_F (float_tpdf_hf_simple, INIT_DITHER_TPDF_HF_F,
    INIT_NS_SIMPLE, ADD_NS_SIMPLE, ADD_DITHER_TPDF_HF_F, UPDATE_ERROR_SIMPLE);
MAKE_QUANTIZE_FUNC_F (float_tpdf_hf_medium, INIT_DITHER_TPDF_HF_F,
    INIT_NS_MEDIUM, ADD_NS_MEDIUM, ADD_DITHER_TPDF_HF_F, UPDATE_ERROR_MEDIUM);
MAKE_QUANTIZE_FUNC_F (float_tpdf_hf_high, INIT_DITHER_TPDF_HF_F, INIT_NS_HIGH,
    ADD_NS_HIGH, ADD_DITHER_TPDF_HF_F, UPDATE_ERROR_HIGH);

static const QuantizeFunc quantize_funcs[] = {
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (int_none_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (int_rpdf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (int_tpdf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (int_tpdf_hf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_none_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_none_error_feedback),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_none_simple),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_none_medium),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_none_high),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_rpdf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_rpdf_error_feedback),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_rpdf_simple),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_rpdf_medium),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_rpdf_high),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_error_feedback),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_simple),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_medium),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_high),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_hf_none),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_hf_error_feedback),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_hf_simple),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_hf_medium),
  (QuantizeFunc) MAKE_QUANTIZE_FUNC_NAME (float_tpdf_hf_high)
};

static void
gst_audio_quantize_setup_noise_shaping (GstAudioQuantize * quant)
{
  switch (quant->ns) {
    case GST_AUDIO_NOISE_SHAPING_HIGH:{
      quant->error_buf = g_new0 (gdouble, quant->channels * 8);
      break;
    }
    case GST_AUDIO_NOISE_SHAPING_MEDIUM:{
      quant->error_buf = g_new0 (gdouble, quant->channels * 5);
      break;
    }
    case GST_AUDIO_NOISE_SHAPING_SIMPLE:{
      quant->error_buf = g_new0 (gdouble, quant->channels * 2);
      break;
    }
    case GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK:
      quant->error_buf = g_new0 (gdouble, quant->channels);
      break;
    case GST_AUDIO_NOISE_SHAPING_NONE:
    default:
      quant->error_buf = NULL;
      break;
  }
  return;
}

static void
gst_audio_quantize_setup_dither (GstAudioQuantize * quant)
{
  switch (quant->dither) {
    case GST_AUDIO_DITHER_TPDF_HF:
      quant->last_random = g_new0 (gdouble, quant->channels);
      break;
    case GST_AUDIO_DITHER_RPDF:
    case GST_AUDIO_DITHER_TPDF:
      quant->last_random = NULL;
      break;
    case GST_AUDIO_DITHER_NONE:
    default:
      quant->last_random = NULL;
      break;
  }
  return;
}

static void
gst_audio_quantize_setup_quantize_func (GstAudioQuantize * quant)
{
  gint index = 0;

  if (quant->ns == GST_AUDIO_NOISE_SHAPING_NONE
      && quant->format == GST_AUDIO_FORMAT_S32) {
    index += quant->dither;
  } else {
    g_assert (quant->format == GST_AUDIO_FORMAT_F64);

    index += 4 + (5 * quant->dither);
    index += quant->ns;
  }
  quant->quantize = quantize_funcs[index];
}

/**
 * gst_audio_quantize_new:
 * @dither: a #GstAudioDitherMethod
 * @ns: a #GstAudioNoiseShapingMethod
 * @flags: #GstAudioQuantizeFlags
 * @format: the #GstAudioFormat of the samples
 * @channels: the amount of channels in the samples
 * @quantizer: the quantizer to use
 *
 * Create a new quantizer object with the given parameters.
 *
 * Returns: a new #GstAudioQuantize. Free with gst_audio_quantize_free().
 */
GstAudioQuantize *
gst_audio_quantize_new (GstAudioDitherMethod dither,
    GstAudioNoiseShapingMethod ns, GstAudioQuantizeFlags flags,
    GstAudioFormat format, guint channels, guint quantizer)
{
  GstAudioQuantize *quant;

  quant = g_slice_new0 (GstAudioQuantize);
  quant->dither = dither;
  quant->ns = ns;
  quant->flags = flags;
  quant->format = format;
  quant->channels = channels;
  quant->quantizer = quantizer;

  gst_audio_quantize_setup_dither (quant);
  gst_audio_quantize_setup_noise_shaping (quant);
  gst_audio_quantize_setup_quantize_func (quant);

  return quant;
}

/**
 * gst_audio_quantize_free:
 * @quant: a #GstAudioQuantize
 *
 * Free a #GstAudioQuantize.
 */
void
gst_audio_quantize_free (GstAudioQuantize * quant)
{
  g_free (quant->error_buf);
  g_free (quant->last_random);

  g_slice_free (GstAudioQuantize, quant);
}

void
gst_audio_quantize_samples (GstAudioQuantize * quant,
    gpointer data, guint samples)
{
  quant->quantize (quant, data, data, samples);
}
