/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org
 */

%%
override gst_pad_set_link_function kwargs

static GstPadLinkReturn
call_link_function (GstPad *pad, GstCaps *caps)
{
	PyObject *function;
	PyObject *retval;
	GstPadLinkReturn ret;
	
	function = pad_private(pad)->link_function;
	
	pyg_block_threads();

	retval = (PyObject*)PyObject_CallFunction (function,
			"OO",
			pad_private(pad)->pad,
    			pyg_boxed_new(GST_TYPE_CAPS, caps, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
        	pyg_unblock_threads();
		return GST_PAD_LINK_REFUSED;
	}

	ret = PyInt_AsLong(retval);

	pyg_unblock_threads();

	return ret;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	static char *kwlist[] = { "link_function", NULL };
	PyObject *link_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_link_funcion",
				kwlist,
				&link_function)) {
		return NULL;
	}

	if (!PyCallable_Check(link_function)) {
		PyErr_SetString(PyExc_TypeError, "link_function not callable");
		return NULL;
	}

	Py_INCREF(link_function);
	py_pad_private(self)->link_function = link_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_link_function(pad, (GstPadLinkFunction)call_link_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_chain_function kwargs

static void
call_chain_function(GstPad *pad, GstBuffer *buf)
{
	PyObject *function;

	function = pad_private(pad)->chain_function;

	pyg_block_threads();

	PyObject_CallFunction (function,
			"OO", 
			pad_private(pad)->pad,
			pyg_boxed_new(GST_TYPE_BUFFER, buf, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
		pyg_unblock_threads();
		return;
	}

	pyg_unblock_threads();
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "chain_function", NULL };
	PyObject *chain_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_chain_funcion",
				kwlist,
				&chain_function)) {
		return NULL;
	}

	if (!PyCallable_Check(chain_function)) {
		PyErr_SetString(PyExc_TypeError, "chain_function not callable");
		return NULL;
	}

	Py_INCREF(chain_function);
	py_pad_private(self)->chain_function = chain_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_chain_function(pad, (GstPadChainFunction)call_chain_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_event_function kwargs

static gboolean
call_event_function (GstPad *pad, GstEvent *event)
{
	PyObject *function;
	PyObject *retval;
	gboolean ret;
	
	function = pad_private(pad)->event_function;
	
	pyg_block_threads();

	retval = PyObject_CallFunction (function,
					"OO",
					pad_private(pad)->pad,
					pyg_boxed_new(GST_TYPE_EVENT, event, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
        	pyg_unblock_threads();
		return FALSE;
	}

	ret = PyInt_AsLong(retval);

	pyg_unblock_threads();

	return ret;
}

static PyObject*
_wrap_gst_pad_set_event_function (PyGObject *self,
				  PyObject  *args,
				  PyObject  *kwargs)
{
	static char *kwlist[] = { "event_function", NULL };
	PyObject *event_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_event_funcion",
				kwlist,
				&event_function)) {
		return NULL;
	}

	if (!PyCallable_Check(event_function)) {
		PyErr_SetString(PyExc_TypeError, "event_function not callable");
		return NULL;
	}

	Py_INCREF(event_function);
	py_pad_private(self)->event_function = event_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_event_function(pad, (GstPadEventFunction)call_event_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_get_function kwargs

static GstData*
call_get_function (GstPad *pad)
{
	PyObject *function;
	PyObject *retval;
	GstData *data = NULL;
	
	function = pad_private(pad)->get_function;
	
	pyg_block_threads();

	retval = PyObject_CallFunction(function, "O", pad_private(pad)->pad);

	if (PyErr_Occurred()) {
		PyErr_Print();
		goto bail;
	} else if (retval == Py_None) {
	    goto bail;
	}

	pygst_data_from_pyobject(retval, &data);

bail:
	pyg_unblock_threads();
	return data;
}

static PyObject*
_wrap_gst_pad_set_get_function (PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "get_function", NULL };
	PyObject *get_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O:GstPad.set_get_funcion",
					 kwlist,
					 &get_function)) {
		return NULL;
	}

	if (!PyCallable_Check(get_function)) {
		PyErr_SetString(PyExc_TypeError, "get_function not callable");
		return NULL;
	}

	Py_INCREF(get_function);
	py_pad_private(self)->get_function = get_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_get_function(pad, (GstPadGetFunction)call_get_function);

	Py_INCREF(Py_None);
	return Py_None;
}
