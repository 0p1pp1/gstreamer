/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org
 */
%%
headers

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
	return (PyGstPadPrivate*)gst_pad_get_element_private(pad);
}
	
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
	PyGstPadPrivate *private;
	GstPad *gpad;

	gpad = (GstPad*)pygobject_get(pad);
	private = (PyGstPadPrivate*)gst_pad_get_element_private(gpad);
	if (private == NULL) {
		/* FIXME need to free this somewhere */
		private = g_new0(PyGstPadPrivate, 1);
		Py_INCREF(pad);
		private->pad = pad;
		gst_pad_set_element_private(gpad, private);
	}
	return private;
}

%%
ignore
  gst_pad_select
  gst_pad_selectv
  gst_pad_load_and_link
%%
override gst_pad_set_link_function kwargs

static GstPadLinkReturn
call_link_function (GstPad *pad, GstCaps *caps)
{
	PyObject *function;
	PyObject *retval;
	GstPadLinkReturn ret;
	PyGILState_STATE state;
	
	function = pad_private(pad)->link_function;
	
	state = pyg_gil_state_ensure();

	retval = (PyObject*)PyObject_CallFunction (function,
			"OO",
			pad_private(pad)->pad,
    			pyg_boxed_new(GST_TYPE_CAPS, caps, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
        	pyg_gil_state_release(state);
		return GST_PAD_LINK_REFUSED;
	}

	ret = PyInt_AsLong(retval);

	pyg_gil_state_release(state);

	return ret;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	static char *kwlist[] = { "link_function", NULL };
	PyObject *link_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_link_funcion",
				kwlist,
				&link_function)) {
		return NULL;
	}

	if (!PyCallable_Check(link_function)) {
		PyErr_SetString(PyExc_TypeError, "link_function not callable");
		return NULL;
	}

	Py_INCREF(link_function);
	py_pad_private(self)->link_function = link_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_link_function(pad, (GstPadLinkFunction)call_link_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_chain_function kwargs

static void
call_chain_function(GstPad *pad, GstBuffer *buf)
{
	PyObject *function;
	PyGILState_STATE state;

	function = pad_private(pad)->chain_function;

	state = pyg_gil_state_ensure();

	PyObject_CallFunction (function,
			"OO", 
			pad_private(pad)->pad,
			pyg_boxed_new(GST_TYPE_BUFFER, buf, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
		pyg_gil_state_release(state);
		return;
	}

	pyg_gil_state_release(state);
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "chain_function", NULL };
	PyObject *chain_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_chain_funcion",
				kwlist,
				&chain_function)) {
		return NULL;
	}

	if (!PyCallable_Check(chain_function)) {
		PyErr_SetString(PyExc_TypeError, "chain_function not callable");
		return NULL;
	}

	Py_INCREF(chain_function);
	py_pad_private(self)->chain_function = chain_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_chain_function(pad, (GstPadChainFunction)call_chain_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_event_function kwargs

static gboolean
call_event_function (GstPad *pad, GstEvent *event)
{
	PyObject *function;
	PyObject *retval;
	gboolean ret;
	PyGILState_STATE state;
	
	function = pad_private(pad)->event_function;
	
	state = pyg_gil_state_ensure();

	retval = PyObject_CallFunction (function,
					"OO",
					pad_private(pad)->pad,
					pyg_boxed_new(GST_TYPE_EVENT, event, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
        	pyg_gil_state_release(state);
		return FALSE;
	}

	ret = PyInt_AsLong(retval);

	pyg_gil_state_release(state);

	return ret;
}

static PyObject*
_wrap_gst_pad_set_event_function (PyGObject *self,
				  PyObject  *args,
				  PyObject  *kwargs)
{
	static char *kwlist[] = { "event_function", NULL };
	PyObject *event_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_event_funcion",
				kwlist,
				&event_function)) {
		return NULL;
	}

	if (!PyCallable_Check(event_function)) {
		PyErr_SetString(PyExc_TypeError, "event_function not callable");
		return NULL;
	}

	Py_INCREF(event_function);
	py_pad_private(self)->event_function = event_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_event_function(pad, (GstPadEventFunction)call_event_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_get_function kwargs

static GstData*
call_get_function (GstPad *pad)
{
	PyObject *function;
	PyObject *retval;
	GstData *data = NULL;
	PyGILState_STATE state;
	
	function = pad_private(pad)->get_function;
	
	state = pyg_gil_state_ensure();

	retval = PyObject_CallFunction(function, "O", pad_private(pad)->pad);

	if (PyErr_Occurred()) {
		PyErr_Print();
		goto bail;
	} else if (retval == Py_None) {
	    goto bail;
	}

	pygst_data_from_pyobject(retval, &data);

bail:
	pyg_gil_state_release(state);
	return data;
}

static PyObject*
_wrap_gst_pad_set_get_function (PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "get_function", NULL };
	PyObject *get_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O:GstPad.set_get_funcion",
					 kwlist,
					 &get_function)) {
		return NULL;
	}

	if (!PyCallable_Check(get_function)) {
		PyErr_SetString(PyExc_TypeError, "get_function not callable");
		return NULL;
	}

	Py_INCREF(get_function);
	py_pad_private(self)->get_function = get_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_get_function(pad, (GstPadGetFunction)call_get_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override-slot GstPad.tp_repr
static PyObject *
_wrap_gst_pad_tp_repr (PyGObject *self)
{
	char *buf;
	PyObject *retval;
  	GstPad *pad;
  	GstElement *parent;

	pad = GST_PAD(self->obj);
	parent = gst_pad_get_parent (pad);
	    
	buf = g_strdup_printf ("<GstPad (%s:%s) at %lx>",
		gst_element_get_name (parent),
		gst_pad_get_name (pad), (long) self->obj);

	retval = PyString_FromString(buf);
	g_free(buf);
	return retval;
}

%%
override gst_pad_query kwargs
static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "ii:GstPad.query", kwlist,
					 &type, &format))
		return NULL;
	
	ret = gst_pad_query(GST_PAD(self->obj), type, &format, &value);
	return PyLong_FromLongLong(value);
}
%%
override gst_pad_convert kwargs
static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value",
				  "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "iOi:GstPad.convert", kwlist,
					 &src_format, &src_value_obj,
					 &dest_format))
		return NULL;
	
	src_value = PyLong_AsLongLong(src_value_obj);
	
	ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value,
			      &dest_format, &dest_value);
	return PyLong_FromLongLong(dest_value);
}
%%
override gst_pad_link kwargs
static PyObject *
_wrap_gst_pad_link(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", NULL };
    PyGObject *sinkpad;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.link", kwlist,
                                     &PyGstPad_Type, &sinkpad))
        return NULL;
    ret = gst_pad_link(GST_PAD(self->obj), GST_PAD(sinkpad->obj));
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_link_filtered kwargs
static PyObject *
_wrap_gst_pad_link_filtered(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", "filtercaps", NULL };
    PyGObject *sinkpad;
    PyObject *py_filtercaps;
    int ret;
    GstCaps *filtercaps = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GstPad.link_filtered",
                                     kwlist, &PyGstPad_Type, &sinkpad,
                                     &py_filtercaps))
        return NULL;
    if (pyg_boxed_check(py_filtercaps, GST_TYPE_CAPS))
        filtercaps = pyg_boxed_get(py_filtercaps, GstCaps);
    else {
        PyErr_SetString(PyExc_TypeError, "filtercaps should be a GstCaps");
        return NULL;
    }
    ret = gst_pad_link_filtered(GST_PAD(self->obj),
                                GST_PAD(sinkpad->obj),
                                filtercaps);
    if (!ret) {
        PyErr_SetString(PyGstExc_LinkError, "link failed");
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_get_negotiated_caps
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	const GstCaps *ret;

	ret = gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	/* pyg_boxed_new handles NULL checking */
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_get_negotiated_caps noargs
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_get_pad_template_caps noargs
static PyObject *
_wrap_gst_pad_get_pad_template_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_pad_template_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps noargs
static PyObject *
_wrap_gst_pad_template_get_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_template_get_caps(GST_PAD_TEMPLATE(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps_by_name kwargs
static PyObject *
_wrap_gst_pad_template_get_caps_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GstCaps *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstPadTemplate.get_caps_by_name", kwlist, &name))
        return NULL;
    ret = (GstCaps*)gst_pad_template_get_caps_by_name(GST_PAD_TEMPLATE(self->obj), name);
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
