/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2005 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org>
 */
%%
ignore
  gst_caps_new_simple
  gst_caps_new_full
  gst_caps_set_simple
%%
override gst_caps_new_empty kwargs
static int
_wrap_gst_caps_new_empty(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	PyObject* item;
	int len, i;

        /* we wrap caps_new, caps_from_string and caps_new_full */
        len = PyTuple_Size(args);
        self->gtype = GST_TYPE_CAPS;
	self->free_on_dealloc = FALSE;
	
        if (len == 0) {
		/* 0 length creates a new empty caps */
		self->boxed = gst_caps_new_empty();
		goto beach;
	} else if (len == 1) {
		/* 1 length is either a string or a structure */
		item = PyTuple_GetItem(args, 0);
		if (PyString_Check(item)) {
			self->boxed = gst_caps_from_string(PyString_AsString(item));
			goto beach;
		} else if (!pyg_boxed_check(item, GST_TYPE_STRUCTURE)) {
                        PyErr_SetString(PyExc_TypeError, "argument must be a string or a GstStructure");
			return -1;
		}		
	}
	/* it's either one GstStructure or several whatevers */
	self->boxed = gst_caps_new_empty();
       	for (i = 0; i < len; i++)
       	{
               	item = PyTuple_GetItem(args, i);
               	if (!pyg_boxed_check(item, GST_TYPE_STRUCTURE))
               	{
                       	PyErr_SetString(PyExc_TypeError, "argument must be a GstStructure");
			gst_caps_free(self->boxed);
			return -1;
		}
		gst_caps_append_structure(self->boxed, pyg_boxed_get(item, GstStructure));
	}

beach:
	if (!self->boxed) {
		PyErr_SetString(PyExc_RuntimeError, "could not create GstCaps object");
		return -1;
	}
	return 0;
}
%%
override gst_caps_get_structure kwargs
static PyObject *
_wrap_gst_caps_get_structure(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    int index;
    GstStructure *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GstCaps.get_structure", kwlist, &index))
        return NULL;
    ret = gst_caps_get_structure(pyg_boxed_get(self, GstCaps), index);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_STRUCTURE, ret, FALSE, FALSE);
}
%%
override-slot GstCaps.tp_as_sequence
static int
caps_length(PyGObject *self)
{
	return gst_caps_get_size((GstCaps*)self->obj);
}

static PyObject *
caps_item(PyGObject *self, int i)
			
{
	GstStructure *structure;
	
	if (i < 0 || i >= gst_caps_get_size((GstCaps*)self->obj)) {
		PyErr_SetString(PyExc_IndexError, "list index out of range");
		return NULL;
	}
	
	structure = gst_caps_get_structure((GstCaps*)self->obj, i);
	return pyg_boxed_new(GST_TYPE_STRUCTURE, structure, TRUE, TRUE);
}

static PySequenceMethods _wrap_gst_caps_tp_as_sequence = {
	(inquiry)caps_length,         /* mp_length */
        NULL,
        NULL,
	(intargfunc)caps_item,
        NULL,
	NULL,
	NULL,
        NULL,
};
%%
override-slot GstCaps.tp_str
static PyObject *
_wrap_gst_caps_tp_str(PyGObject *self)
{
    gchar *tmp;
    PyObject *retval;
    
    tmp = gst_caps_to_string((GstCaps*)self->obj);
    retval = PyString_FromString(tmp);
    g_free(tmp);

    return retval;
}
