/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2002 David I. Lehn
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: David I. Lehn <dlehn@users.sourceforge.net>
 */
%%
headers
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "common.h"

#include <gst/gst.h>
#include <gst/gsterror.h>
#include <gst/gstqueue.h>
#include <gst/gsttypefind.h>
#include <gst/gsttag.h>

extern gboolean pygst_data_from_pyobject (PyObject *object, GstData **data);
static PyObject *_wrap_gst_element_factory_make(PyObject *self, PyObject *args, PyObject *kwargs);

GSList *mainloops = NULL;
void
_pygst_main_quit(void)
{
    if (!mainloops)
	    g_error ("Quit more loops than there are");
    else {
	GMainLoop *loop = mainloops->data;

	mainloops = g_slist_delete_link (mainloops, mainloops);
	g_main_loop_quit (loop);
	g_main_loop_unref (loop);
    }
}

void
_pygst_main(void)
{
    GMainLoop *loop;

    loop = g_main_loop_new (NULL, FALSE);
    mainloops = g_slist_prepend (mainloops, loop);

    g_main_loop_run (loop);
}


%%
include
  gstbin.override
  gstbuffer.override
  gstpad-handlers.override
%%
init
PyGstPipeline_Type.tp_new = PyType_GenericNew;
PyGstThread_Type.tp_new = PyType_GenericNew;
//PyGstQueue_Type.tp_new = PyType_GenericNew;
PyGstBin_Type.tp_new = PyType_GenericNew; // Shouldn't this be enough?
%%
modulename gst
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
  _*
  *_copy
  *_error_quark
  *_free
  *_get_type
  *_private
  *_thyself
  *_valist
  gst_class_*
  gst_init*
  gst_interface_*
  gst_tag_list_get_*
  gst_value_*
  gst_xml_*
%%
ignore
  gst_alloc_trace_list
  gst_alloc_trace_get
  gst_caps_new_simple
  gst_caps_new_full
  gst_caps_set_simple
  gst_element_get
  gst_element_set
  gst_element_get_property
  gst_element_set_property
  gst_error_get_message
  gst_event_new_discontinuous
  gst_object_default_deep_notify
  gst_object_check_uniqueness
  gst_object_replace
  gst_pad_select
  gst_pad_selectv
  gst_pad_load_and_link
  gst_parse_launchv
  gst_tag_list_add
  gst_tag_list_add_values
  gst_tag_list_add_valist_values
  gst_tag_list_copy_value
  gst_trace_read_tsc
%%
override gst_element_get_pad_list noargs
static PyObject *
_wrap_gst_element_get_pad_list(PyGObject *self)
{
	GList *l, *pads;
	PyObject *list;
	
	pads = GST_ELEMENT_PADS(GST_ELEMENT(self->obj));

	list = PyList_New(0);
	for (l = pads; l; l = l->next) {
		GstPad *pad = (GstPad*)l->data;
		PyList_Append(list, pygobject_new(G_OBJECT(pad)));
	}
		
	return list;
}
%%
override gst_element_get_pad_template_list noargs
static PyObject *
_wrap_gst_element_get_pad_template_list(PyGObject *self)
{
	GList *l, *pads;
	PyObject *list;
	
	pads = (GList*)gst_element_get_pad_template_list(GST_ELEMENT(self->obj));

	list = PyList_New(0);
	for (l = pads; l; l = l->next) {
		GstPad *pad = (GstPad*)l->data;
		PyList_Append(list, pygobject_new(G_OBJECT(pad)));
	}
		
	return list;
}
%%
override gst_element_set_state kwargs
static PyObject *
_wrap_gst_element_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "state", NULL };
	PyObject *py_state = NULL;
	GstElementState state;
	gint ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstElement.set_state", kwlist, &py_state))
		return NULL;
	if (pyg_flags_get_value(GST_TYPE_ELEMENT_STATE, py_state, (gint *)&state))
		return NULL;

	Py_BEGIN_ALLOW_THREADS;

	ret = gst_element_set_state(GST_ELEMENT(self->obj), state);

	Py_END_ALLOW_THREADS;

	return PyInt_FromLong(ret);
}
%%
override-slot GstPad.tp_repr
static PyObject *
_wrap_gst_pad_tp_repr (PyGObject *self)
{
	char *buf;
	PyObject *retval;
  	GstPad *pad;
  	GstElement *parent;
	
	buf = g_strdup_printf ("<GstPad (%s:%s) at %lx>",
		gst_element_get_name (parent),
		gst_pad_get_name (pad), (long) self->obj);

	retval = PyString_FromString(buf);
	g_free(buf);
	return retval;
}

%%
override gst_pad_query kwargs
static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "ii:GstPad.query", kwlist,
					 &type, &format))
		return NULL;
	
	ret = gst_pad_query(GST_PAD(self->obj), type, &format, &value);
	return PyLong_FromLongLong(value);
}
%%
override gst_element_query kwargs
static PyObject *
_wrap_gst_element_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "ii:GstElement.query", kwlist,
					 &type, &format))
		return NULL;
	
	ret = gst_element_query(GST_ELEMENT(self->obj), type, &format, &value);
	return PyLong_FromLongLong(value);
}
%%
override gst_pad_convert kwargs
static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value",
				  "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value = 0;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "iOi:GstPad.convert", kwlist,
					 &src_format, &src_value_obj,
					 &dest_format))
		return NULL;
	
	src_value = PyLong_AsLongLong(src_value_obj);
	
	ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value,
			      &dest_format, &dest_value);
	return PyLong_FromLongLong(dest_value);
}
%%
override gst_element_convert kwargs
static PyObject *
_wrap_gst_element_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value", "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOi:GstElement.convert", kwlist, &src_format, &src_value_obj, &dest_format))
		return NULL;
	src_value = PyLong_AsLongLong(src_value_obj);
	dest_value = 0;
	ret = gst_element_convert(GST_ELEMENT(self->obj), src_format, src_value, &dest_format, &dest_value);
	if (!ret) {
		PyErr_SetString(PyExc_RuntimeError, "conversion could not be performed");
		return NULL;
	}
	
	return PyInt_FromLong(dest_value);
}
%%
override gst_element_link_many args
static PyObject *
_wrap_gst_element_link_many(PyObject *self, PyObject *args)
{
	PyGObject *element, *element2;
	int i, len;

	len = PyTuple_Size(args);
	if (len < 2)
	{
		PyErr_SetString(PyExc_TypeError, "gst.element_link_many requires at least two argument");
		return NULL;
	}
       

	for (i = 0; i < len; i++)
	{
		element = (PyGObject*)PyTuple_GetItem(args, i);
		if (!pygobject_check(element, &PyGstElement_Type))
		{
			PyErr_SetString(PyExc_TypeError, "argument must be a GstElement");
			return NULL;
		}
	}

	/* Mimic the real gst_element_link_many */
	element = (PyGObject*)PyTuple_GetItem(args, 0);
	element2 = (PyGObject*)PyTuple_GetItem(args, 1);

	i = 2;
	while (1) {

		if (!gst_element_link(GST_ELEMENT(element->obj), GST_ELEMENT(element2->obj)))
			return PyInt_FromLong(0);

		if (i >= len)
			break;
		
		element = element2;
		element2 = (PyGObject*)PyTuple_GetItem(args, i);
	
		i++;
	}

	return PyInt_FromLong(1);
}
%%
override gst_element_unlink_many args
static PyObject *
_wrap_gst_element_unlink_many(PyObject *self, PyObject *args)
{
	PyGObject *element, *element2;
	int i, len;

	len = PyTuple_Size(args);
	if (len < 2)
	{
		PyErr_SetString(PyExc_TypeError, "gst.element_unlink_many requires at least two argument");
		return NULL;
	}
       

	for (i = 0; i < len; i++)
	{
		element = (PyGObject*)PyTuple_GetItem(args, i);
		if (!pygobject_check(element, &PyGstElement_Type))
		{
			PyErr_SetString(PyExc_TypeError, "argument must be a GstElement");
			return NULL;
		}
	}

	/* Mimic the real gst_element_unlink_many */
	element = (PyGObject*)PyTuple_GetItem(args, 0);
	element2 = (PyGObject*)PyTuple_GetItem(args, 1);

	i = 2;
	while (1) {
		gst_element_unlink(GST_ELEMENT(element->obj), GST_ELEMENT(element2->obj));

		if (i >= len)
			break;
		
		element = element2;
		element2 = (PyGObject*)PyTuple_GetItem(args, i);
	
		i++;
	}

	return PyInt_FromLong(1);
}
%%
override GstPad.get_negotiated_caps
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	const GstCaps *ret;

	ret = gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	/* pyg_boxed_new handles NULL checking */
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_caps_new_empty kwargs
static int
_wrap_gst_caps_new_empty(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	PyObject* item;
	int len, i;

        /* we wrap caps_new, caps_from_string and caps_new_full */
        len = PyTuple_Size(args);
        self->gtype = GST_TYPE_CAPS;
	self->free_on_dealloc = FALSE;
	
        if (len == 0) {
		/* 0 length creates a new empty caps */
		self->boxed = gst_caps_new_empty();
		goto beach;
	} else if (len == 1) {
		/* 1 length is either a string or a structure */
		item = PyTuple_GetItem(args, 0);
		if (PyString_Check(item)) {
			self->boxed = gst_caps_from_string(PyString_AsString(item));
			goto beach;
		} else if (!pyg_boxed_check(item, GST_TYPE_STRUCTURE)) {
                        PyErr_SetString(PyExc_TypeError, "argument must be a string or a GstStructure");
			return -1;
		}		
	}
	/* it's either one GstStructure or several whatevers */
	self->boxed = gst_caps_new_empty();
       	for (i = 0; i < len; i++)
       	{
               	item = PyTuple_GetItem(args, i);
               	if (!pyg_boxed_check(item, GST_TYPE_STRUCTURE))
               	{
                       	PyErr_SetString(PyExc_TypeError, "argument must be a GstStructure");
			gst_caps_free(self->boxed);
			return -1;
		}
		gst_caps_append_structure(self->boxed, pyg_boxed_get(item, GstStructure));
	}

beach:
	if (!self->boxed) {
		PyErr_SetString(PyExc_RuntimeError, "could not create GstCaps object");
		return -1;
	}
	return 0;
}
%%
override gst_caps_get_structure kwargs
static PyObject *
_wrap_gst_caps_get_structure(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    int index;
    GstStructure *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GstCaps.get_structure", kwlist, &index))
        return NULL;
    ret = gst_caps_get_structure(pyg_boxed_get(self, GstCaps), index);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_STRUCTURE, ret, FALSE, FALSE);
}
%%
override-slot GstCaps.tp_as_sequence
static int
caps_length(PyGObject *self)
{
	return gst_caps_get_size((GstCaps*)self->obj);
}

static PyObject *
caps_item(PyGObject *self, int i)
			
{
	GstStructure *structure;
	
	if (i < 0 || i >= gst_caps_get_size((GstCaps*)self->obj)) {
		PyErr_SetString(PyExc_IndexError, "list index out of range");
		return NULL;
	}
	
	structure = gst_caps_get_structure((GstCaps*)self->obj, i);
	return pyg_boxed_new(GST_TYPE_STRUCTURE, structure, TRUE, TRUE);
}

static PySequenceMethods _wrap_gst_caps_tp_as_sequence = {
	(inquiry)caps_length,         /* mp_length */
        NULL,
        NULL,
	(intargfunc)caps_item,
        NULL,
	NULL,
	NULL,
        NULL,
};
%%
override-slot GstCaps.tp_str
static PyObject *
_wrap_gst_caps_tp_str(PyGObject *self)
{
    gchar *tmp;
    PyObject *retval;
    
    tmp = gst_caps_to_string((GstCaps*)self->obj);
    retval = PyString_FromString(tmp);
    g_free(tmp);

    return retval;
}
%%
define GstTagList.keys noargs
void
tag_foreach_func_dict (const GstTagList *list,
		       const gchar      *tag,
		       PyObject         *dict)
{
	int count;
	guint i;
	const GValue *gvalue;
	PyObject *value;
	gchar *key;
    
	count = gst_tag_list_get_tag_size(GST_TAG_LIST(list), tag);

	for (i = 0; i < count; i++) {
		gvalue = gst_tag_list_get_value_index(GST_TAG_LIST(list), tag, i);
		value = pyg_value_as_pyobject(gvalue, TRUE);
		key = g_strdup (tag);
		PyDict_SetItemString(dict, key, value);
		g_free (key);
		Py_DECREF(value);
	}
}
void
tag_foreach_func_list (const GstTagList *list,
		       const gchar      *tag,
		       PyObject         *py_list)
{
	int count;
    
	count = gst_tag_list_get_tag_size(GST_TAG_LIST(list), tag);
	if (count == 0)
		PyErr_SetString(PyExc_KeyError, tag);
	else if (count == 1)
		PyList_Append(py_list, PyString_FromString(tag));
	else if (count > 1)
		PyErr_SetString(PyExc_TypeError, "lists are currently unspported");
}

static PyObject*
_wrap_gst_tag_list_keys(PyGObject *self)
{
	PyObject *dict;

	dict = PyList_New(0);
    
	gst_tag_list_foreach(GST_TAG_LIST(self->obj),
			     (GstTagForeachFunc)tag_foreach_func_list,
			     (gpointer)dict);
    
	return dict;
}
%%
override-slot GstTagList.tp_as_mapping
static int
_wrap_gst_tag_list_length(PyGObject *self)
{
	return gst_structure_n_fields((GstStructure*)self->obj);
}

static PyObject *
_wrap_gst_tag_list_subscript(PyGObject *self, PyObject *py_key)
{
	PyObject *v = NULL;
	char *key = PyString_AsString(py_key);
	
	int count = gst_tag_list_get_tag_size(GST_TAG_LIST(self->obj), key);
	if (count == 0) {
		PyErr_SetObject(PyExc_KeyError, py_key);
	} else if (count == 1) {
		const GValue *gvalue;
		gvalue = gst_tag_list_get_value_index(GST_TAG_LIST(self->obj), key, 0);
		v = pyg_value_as_pyobject(gvalue, TRUE);
	} else {
		PyErr_SetString(PyExc_TypeError, "lists are currently unspported");
	}
		
	if (v != NULL)
		Py_INCREF(v);
	return v;
}

static PySequenceMethods _wrap_gst_tag_list_tp_as_mapping = {
	(inquiry)_wrap_gst_tag_list_length,         /* mp_length */
	(binaryfunc)_wrap_gst_tag_list_subscript,   /* mp_subscript */
	NULL,
};

%%
define GstTagList.has_key args
static PyObject*
_wrap_gst_tag_list_has_key(PyGObject *self, PyObject *args)
{
	gchar *key;
	const GValue *gvalue;
    
	if (!PyArg_ParseTuple(args, "s:GstTagList.has_key", &key))
		return NULL;

	gvalue = gst_tag_list_get_value_index(GST_TAG_LIST(self->obj), key, 0);

	return PyInt_FromLong(gvalue != NULL);
}    
%%
define GstTagList.get
static PyObject *
_wrap_gst_tag_list_get(PyGObject *self, PyObject *args)
{
	char *key;
	PyObject *failobj = Py_None;
	PyObject *val = NULL;
	const GValue *gvalue;
	
	if (!PyArg_ParseTuple(args, "s|O:GstTagList.get", &key, &failobj))
		return NULL;

	gvalue = gst_tag_list_get_value_index(GST_TAG_LIST(self->obj), key, 0);
	if (gvalue != NULL) {
		int count = gst_tag_list_get_tag_size(GST_TAG_LIST(self->obj), key);
		if (count == 0) {
			PyErr_SetString(PyExc_KeyError, key);
		} else if (count == 1) {
			gvalue = gst_tag_list_get_value_index(GST_TAG_LIST(self->obj), key, 0);
			val = pyg_value_as_pyobject(gvalue, TRUE);
		} else {
			PyErr_SetString(PyExc_TypeError, "lists are currently unspported");
		}
	}

	if (val == NULL)
		val = failobj;
	Py_INCREF(val);
	return val;
}

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
	return (PyGstPadPrivate*)gst_pad_get_element_private(pad);
}
	
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
	PyGstPadPrivate *private;
	GstPad *gpad;

	gpad = (GstPad*)pygobject_get(pad);
	private = (PyGstPadPrivate*)gst_pad_get_element_private(gpad);
	if (private == NULL) {
		/* FIXME need to free this somewhere */
		private = g_new0(PyGstPadPrivate, 1);
		Py_INCREF(pad);
		private->pad = pad;
		gst_pad_set_element_private(gpad, private);
	}
	return private;
}
%%
override gst_structure_new kwargs
static int
_wrap_gst_structure_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "name", NULL };
	char *name;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstStructure.__init__", kwlist, &name))
		return -1;
	
	self->gtype = GST_TYPE_STRUCTURE;
	self->free_on_dealloc = FALSE;

	self->boxed = gst_structure_new(name, NULL);

	if (!self->boxed) {
		PyErr_SetString(PyExc_RuntimeError, "could not create GstStructure object");
		return -1;
	}
	self->free_on_dealloc = TRUE;
	return 0;
}
%%
override gst_structure_set_value kwargs
static PyObject *
_wrap_gst_structure_set_value(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "field", "value", NULL };
	char *field;
	PyObject *py_value = NULL;
	GValue value = { 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "sO:GstStructure.set_value",
					 kwlist, &field, &py_value))
		return NULL;
	
	g_value_init(&value, G_TYPE_STRING);
	if (pyg_value_from_pyobject(&value, py_value) != 0) {
		return NULL;
	}
	gst_structure_set_value(pyg_boxed_get(self, GstStructure), field, &value);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_structure_get_int kwargs
static PyObject *
_wrap_gst_structure_get_int(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "fieldname", NULL };
	char *fieldname;
	int value;
	
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "s:GstStructure.get_int",
					 kwlist, &fieldname))
		return NULL;

	if (gst_structure_get_int(pyg_boxed_get(self, GstStructure), fieldname, &value))
		return PyInt_FromLong(value);

	/* XXX: Raise exception? */
	Py_INCREF(Py_None);
	return Py_None;
}
%%
define GstStructure.has_key args
static PyObject*
_wrap_gst_structure_has_key(PyGObject *self, PyObject *args)
{
	gchar *key;
	gboolean has_field;
    
	if (!PyArg_ParseTuple(args, "s:GstStructure.has_key", &key))
		return NULL;

	has_field = gst_structure_has_field((GstStructure*)self->obj, key);
	    
	return PyBool_FromLong(has_field);
}    
%%
override-slot GstStructure.tp_as_mapping
static int
_wrap_gst_structure_length(PyGObject *self)
{
	return gst_structure_n_fields((GstStructure*)self->obj);
}

static PyObject *
_wrap_gst_structure_subscript(PyGObject *self, PyObject *py_key)
{
	PyObject *v = NULL;
	const char *field = PyString_AsString(py_key);
	
	if (gst_structure_has_field((GstStructure*)self->obj, field)) {
		const GValue *gvalue;
		gvalue = gst_structure_get_value((GstStructure*)self->obj, field);
		g_assert(gvalue != NULL);
		v = pyg_value_as_pyobject(gvalue, TRUE);
	} else {
		PyErr_SetString(PyExc_KeyError, field);
	}
		
	if (v != NULL)
		Py_INCREF(v);
	return v;
}

static int
_wrap_gst_structure_ass_subscript(PyGObject *self,
				  PyObject *py_key,
				  PyObject *py_value)
{
	const char *key;
	GstStructure* structure;

	structure = (GstStructure*)self->obj;
	key = PyString_AsString(py_key);
	if (py_value != NULL) {
	    if (PyString_Check(py_value)) {
#if 0		
		GValue *value = NULL;
		gst_structure_field_from_string(PyString_AsString(py_value), value);
		g_print ("gvalue: %s %s %s\n",
			 PyString_AsString(py_value),
			 gst_value_serialize(value),
			 G_VALUE_TYPE_NAME(value));
		gst_structure_set_value(structure, key, value);
#else
		GValue value = { 0, };
		g_value_init (&value, G_TYPE_STRING);
		gst_value_deserialize(&value, PyString_AsString(py_value));
		gst_structure_set_value(structure, key, &value);
		g_value_unset(&value);
#endif		
		// gst_structure_set(structure, key, G_TYPE_STRING, PyString_AsString(py_value), NULL);
	    } else if (PyInt_Check(py_value))
		gst_structure_set(structure, key, G_TYPE_INT, PyInt_AsLong(py_value), NULL);
	    else if (PyFloat_Check(py_value))
		gst_structure_set(structure, key, G_TYPE_DOUBLE, PyFloat_AsDouble(py_value), NULL);
#if 0	    
	    g_value_init(&value, g_type_from_name("PyObject"));
	    if (pyg_value_from_pyobject(&value, py_value)) {
		PyErr_SetString(PyExc_TypeError, "can't convert value");
		return -1;
	    }
	    
	    gst_structure_set_value(structure, key, &value);
	    g_value_unset(&value);
#endif	    
	} else {
	    gst_structure_remove_field(structure, key);
	}
	
	return 0;
}

static PyMappingMethods _wrap_gst_structure_tp_as_mapping = {
	(inquiry)_wrap_gst_structure_length,         /* mp_length */
	(binaryfunc)_wrap_gst_structure_subscript,   /* mp_subscript */
	(objobjargproc)_wrap_gst_structure_ass_subscript /* mp_ass_subscript */
};

%%
override gst_structure_foreach kwargs
static gboolean
pygst_structure_foreach_marshal(GQuark field_id,
				GValue *value,
				gpointer user_data)
{
	PyGstCustomNotify *cunote = user_data;
	PyObject *py_field, *py_value, *retobj;
	gboolean retval = TRUE;

	g_assert(cunote->func);

	pyg_block_threads();

	py_field = Py_BuildValue("s", g_quark_to_string(field_id));
	py_value = pyg_value_as_pyobject(value, FALSE);
	if (cunote->data)
		retobj = PyEval_CallFunction(cunote->func, "(NNO)",
					     py_field, py_value,
					     cunote->data);
	else
		retobj = PyEval_CallFunction(cunote->func, "(NN)",
					     py_field, py_value);

	if (PyErr_Occurred () || (retobj == NULL) || (retobj == Py_None)) {
		PyErr_Print ();
		retval = FALSE;
	} else if (retobj != Py_None) {
		retval = PyInt_AsLong(retobj);
	}

	Py_XDECREF(retobj);

	pyg_unblock_threads();

	return retval;
}

static PyObject *
_wrap_gst_structure_foreach (PyGObject *self,
			     PyObject *args,
			     PyObject *kwargs)
{
	static char *kwlist[] = { "foreach_function", "args", NULL };
	PyObject *pyfunc, *pyarg = NULL;
	PyGstCustomNotify cunote;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O|O:GstStructure.foreach",
					 kwlist,
					 &pyfunc, &pyarg)) {
		return NULL;
	}

	if (!PyCallable_Check(pyfunc)) {
		PyErr_SetString(PyExc_TypeError, "foreach_function not callable");
		return NULL;
	}

	cunote.func = pyfunc;
	cunote.data = pyarg;
	gst_structure_foreach(pyg_boxed_get(self, GstStructure),
			      pygst_structure_foreach_marshal,
			      &cunote);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override-slot GstStructure.tp_repr
static PyObject *
_wrap_gst_structure_tp_repr (PyGObject *self)
{
	char *buf;
	PyObject *retval;
	
	buf = g_strdup_printf("<GstStructure (%s) at %lx>",
			      gst_structure_get_name((GstStructure*)self->obj),
			      (long)self->obj);

	retval = PyString_FromString(buf);
	g_free(buf);
	return retval;
}
%%
override gst_structure_from_string kwargs
static PyObject *
_wrap_gst_structure_from_string(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "string", NULL };
    char *string;
    GstStructure *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:structure_from_string", kwlist, &string))
        return NULL;
    
    ret = gst_structure_from_string(string, NULL);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_STRUCTURE, ret, TRUE, TRUE);
}
%%
override gst_tag_list_foreach kwargs
static gboolean
pygst_tag_list_foreach_marshal(GstTagList *list,
			       const gchar *tag,
			       gpointer user_data)
{
	PyGstCustomNotify *cunote = user_data;
	PyObject *py_list;
	PyObject *py_key, *retobj;
	gboolean retval = TRUE;

	g_assert(cunote->func);

	pyg_block_threads();

	py_list = pyg_boxed_new(GST_TYPE_TAG_LIST, list, TRUE, TRUE);
	py_key = Py_BuildValue("s", tag);
	if (cunote->data)
		retobj = PyEval_CallFunction(cunote->func, "(NNO)",
					     py_list,
					     py_key,
					     cunote->data);
	else
		retobj = PyEval_CallFunction(cunote->func, "(NN)",
					     py_list,
					     py_key);

	if (PyErr_Occurred () || (retobj == NULL) || (retobj == Py_None)) {
		PyErr_Print ();
		retval = FALSE;
	} else if (retobj != Py_None) {
		retval = PyInt_AsLong(retobj);
	}

	Py_XDECREF(retobj);

	pyg_unblock_threads();

	return retval;
}

static PyObject *
_wrap_gst_tag_list_foreach (PyGObject *self,
			    PyObject *args,
			    PyObject *kwargs)
{
	static char *kwlist[] = { "foreach_function", "args", NULL };
	PyObject *pyfunc, *pyarg = NULL;
	PyGstCustomNotify cunote;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O|O:GstTagList.foreach",
					 kwlist, &pyfunc, &pyarg))
		return NULL;

	if (!PyCallable_Check(pyfunc)) {
		PyErr_SetString(PyExc_TypeError, "foreach_function not callable");
		return NULL;
	}

	cunote.func = pyfunc;
	cunote.data = pyarg;
	gst_tag_list_foreach(pyg_boxed_get(self, GstTagList),
			     (GstTagForeachFunc)pygst_tag_list_foreach_marshal,
			     &cunote);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_tag_list_get_value_index kwargs
static PyObject *
_wrap_gst_tag_list_get_value_index (PyGObject *self,
				    PyObject *args,
				    PyObject *kwargs)
{
	static char *kwlist[] = { "tag", "index", NULL };
	char *tag;
	int index;
	const GValue *gvalue;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "si:GstTagList.get_value_index",
					 kwlist, &tag, &index))
		return NULL;

	gvalue = gst_tag_list_get_value_index(pyg_boxed_get(self, GstTagList),
					      tag,
					      index);

	return pyg_value_as_pyobject(gvalue, FALSE);
}
%%
override gst_pad_get_negotiated_caps noargs
static PyObject *
_wrap_gst_pad_get_negotiated_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_negotiated_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_get_pad_template_caps noargs
static PyObject *
_wrap_gst_pad_get_pad_template_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_get_pad_template_caps(GST_PAD(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps noargs
static PyObject *
_wrap_gst_pad_template_get_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_pad_template_get_caps(GST_PAD_TEMPLATE(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_type_find_factory_get_caps noargs
static PyObject *
_wrap_gst_type_find_factory_get_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_type_find_factory_get_caps(GST_TYPE_FIND_FACTORY(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps_by_name kwargs
static PyObject *
_wrap_gst_pad_template_get_caps_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GstCaps *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstPadTemplate.get_caps_by_name", kwlist, &name))
        return NULL;
    ret = (GstCaps*)gst_pad_template_get_caps_by_name(GST_PAD_TEMPLATE(self->obj), name);
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_type_find_factory_get_caps noargs
static PyObject *
_wrap_gst_type_find_factory_get_caps(PyGObject *self)
{
	GstCaps *ret = (GstCaps*)gst_type_find_factory_get_caps(GST_TYPE_FIND_FACTORY(self->obj));
	return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override-attr GError.domain
static PyObject *
_wrap_gst_g_error__get_domain(PyGObject *self, void *closure)
{
    return PyString_FromString(g_quark_to_string(((GError*)self->obj)->domain));
}
%%
override-slot GError.tp_str
static PyObject *
_wrap_gst_g_error_tp_str(PyGObject *self)
{
    GError *error = (GError*)self->obj;
    return PyString_FromString(gst_error_get_message (error->domain,
						      error->code));
}
%%
override gst_main noargs
static PyObject *
_wrap_gst_main(PyObject *self)
{
	Py_BEGIN_ALLOW_THREADS;

	_pygst_main();

	Py_END_ALLOW_THREADS;
	
	if (PyErr_Occurred())
		return NULL;
	
        Py_INCREF(Py_None);
        return Py_None;

}
%%
override gst_main_quit args
static PyObject *
_wrap_gst_main_quit(PyObject *self)
{

    _pygst_main_quit();
    
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override-slot GstElement.tp_init kwargs
static int
_wrap_gst_element_tp_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
	return 1;
}
%%
override-slot GstElement.tp_new kwargs
static PyObject *
_wrap_gst_element_tp_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return _wrap_gst_element_factory_make(NULL, args, kwargs);
}
%%
override gst_registry_pool_plugin_list noargs
static PyObject *
_wrap_gst_registry_pool_plugin_list(PyGObject *self)
{
	GList *l, *plugins;
	PyObject *list;
	
	plugins = gst_registry_pool_plugin_list();

	list = PyList_New(0);
	for (l = plugins; l; l = l->next) {
		GstPlugin *plugin = (GstPlugin*)l->data;
		PyList_Append(list,
			      pyg_boxed_new(GST_TYPE_PLUGIN, plugin, TRUE, TRUE));
	}
	g_list_free(plugins);
	
	return list;
}
%%
override gst_registry_pool_feature_list
static PyObject *
_wrap_gst_registry_pool_feature_list(PyGObject *self, PyObject *args)
{
	GList *l, *features;
	PyObject *pygtype, *list;
	GType gtype;
	
	if (!PyArg_ParseTuple(args, "O:registry_pool_feature_list",
			      &pygtype))
		return NULL;

	gtype = pyg_type_from_object (pygtype);
	if (!gtype)
		return NULL;
	
	features = gst_registry_pool_feature_list(gtype);

	list = PyList_New(0);
	for (l = features; l; l = l->next) {
		GstPluginFeature *feature = (GstPluginFeature*)l->data;
		PyList_Append(list, pygobject_new (G_OBJECT (feature)));

	}
	g_list_free(features);
		
	return list;
}
