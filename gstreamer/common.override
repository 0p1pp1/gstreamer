/* -*- Mode: C; c-basic-offset: 4 -*- */
/* gst-python
 * Copyright (C) 2002 David I. Lehn
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: David I. Lehn <dlehn@users.sourceforge.net>
 */
%%
headers
#include <Python.h>

#include "pygobject.h"
#include <gst/gst.h>

#include "common.h"

typedef struct {
	PyGObject *pad;
	PyObject *link_function;
	PyObject *chain_function;
} PyGstPadPrivate;

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
	return (PyGstPadPrivate*)gst_pad_get_element_private(pad);
}
	
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
	PyGstPadPrivate *private;
	GstPad *gpad;

	gpad = (GstPad*)pygobject_get(pad);
	private = (PyGstPadPrivate*)gst_pad_get_element_private(gpad);
	if (private == NULL) {
		/* FIXME need to free this somewhere */
		private = g_new0(PyGstPadPrivate, 1);
		Py_INCREF(pad);
		private->pad = pad;
		gst_pad_set_element_private(gpad, private);
	}
	return private;
}
	
%%
modulename gstreamer
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
 _*
 gstreamer_*init
 *_get_type
%%
override gst_pad_set_link_function kwargs

static GstPadLinkReturn
call_link_function (GstPad *pad, GstCaps *caps)
{
	PyObject *function;
	PyObject *retval;
	GstPadLinkReturn ret;
	
	function = pad_private(pad)->link_function;
	
	pyg_block_threads();

	retval = (PyObject*)PyObject_CallFunction (function,
			"OO",
			pad_private(pad)->pad,
    			pyg_boxed_new(GST_TYPE_CAPS, caps, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
        	pyg_unblock_threads();
		return GST_PAD_LINK_REFUSED;
	}

	ret = PyInt_AsLong(retval);

	pyg_unblock_threads();

	return ret;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
		PyObject  *args,
		PyObject  *kwargs)
{
	static char *kwlist[] = { "link_function", NULL };
	PyObject *link_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_link_funcion",
				kwlist,
				&link_function)) {
		return NULL;
	}

	if (!PyCallable_Check(link_function)) {
		PyErr_SetString(PyExc_TypeError, "link_function not callable");
		return NULL;
	}

	Py_INCREF(link_function);
	py_pad_private(self)->link_function = link_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_link_function(pad, call_link_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_pad_set_chain_function kwargs

static void
call_chain_function(GstPad *pad, GstBuffer *buf)
{
	PyObject *function;

	function = pad_private(pad)->chain_function;

	pyg_block_threads();

	PyObject_CallFunction (function,
			"OO", 
			pad_private(pad)->pad,
			pyg_boxed_new(GST_TYPE_BUFFER, buf, TRUE, TRUE));

	if (PyErr_Occurred ()) {
		PyErr_Print ();
		pyg_unblock_threads();
		return;
	}

	pyg_unblock_threads();
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
				PyObject  *args,
				PyObject  *kwargs)
{
	static char *kwlist[] = { "chain_function", NULL };
	PyObject *chain_function;
	GstPad *pad;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				"O:GstPad.set_chain_funcion",
				kwlist,
				&chain_function)) {
		return NULL;
	}

	if (!PyCallable_Check(chain_function)) {
		PyErr_SetString(PyExc_TypeError, "chain_function not callable");
		return NULL;
	}

	Py_INCREF(chain_function);
	py_pad_private(self)->chain_function = chain_function;
	pad = (GstPad*)pygobject_get(self);
	gst_pad_set_chain_function(pad, call_chain_function);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_buffer_get_data

static PyObject*
_wrap_gst_buffer_get_data(PyObject *self)
{
	GstBuffer *buf;

	buf = pyg_boxed_get(self, GstBuffer);

	return PyString_FromStringAndSize(
			GST_BUFFER_DATA(buf),
			GST_BUFFER_SIZE(buf));
}
%%
override gst_buffer_set_data kwargs

static PyObject*
_wrap_gst_buffer_set_data(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"data", NULL};
	PyObject *data;
	GstBuffer *buf;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstBuffer:set_data", kwlist, &data)) {
		return NULL;
	}
	if (!PyString_Check(data)) {
		PyErr_SetString(PyExc_TypeError, "data should be a string");
		return NULL;
	}
	buf = pyg_boxed_get(self, GstBuffer);
	if (GST_BUFFER_FLAGS(buf) & GST_BUFFER_READONLY) {
		PyErr_SetString(PyExc_TypeError, "set_data can't use a READONLY buffer");
		return NULL;
	}
	GST_BUFFER_SIZE(buf) = PyString_Size(data);
	GST_BUFFER_DATA(buf) = g_new0(char, GST_BUFFER_SIZE(buf));

	memcpy(GST_BUFFER_DATA(buf),
			PyString_AsString(data),
			PyString_Size(data));

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gst_bin_iterate

static PyObject *
_wrap_gst_bin_iterate(PyGObject *self)
{
	int ret;

	pyg_unblock_threads();
	ret = gst_bin_iterate(GST_BIN(self->obj));
	pyg_block_threads();
	return PyInt_FromLong(ret);
}
%%
override gst_element_set_state kwargs

static PyObject *
_wrap_gst_element_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "state", NULL };
	PyObject *py_state = NULL;
	GstElementState state;
	gint ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstElement.set_state", kwlist, &py_state))
		return NULL;
	if (pyg_flags_get_value(GST_TYPE_ELEMENT_STATE, py_state, (gint *)&state))
		return NULL;
	pyg_unblock_threads();
	ret = gst_element_set_state(GST_ELEMENT(self->obj), state);
	pyg_block_threads();
	return PyInt_FromLong(ret);
}
%%
override gst_pad_query kwargs

static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GstPad.query", kwlist, &type, &format))
		return NULL;
	value = 0;
	ret = gst_pad_query(GST_PAD(self->obj), type, &format, &value);
	return Py_BuildValue("(bL)", ret, value);
}
%%
override gst_element_query kwargs

static PyObject *
_wrap_gst_element_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "type", "format", NULL };
	GstQueryType type;
	GstFormat format;
	gint64 value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GstElement.query", kwlist, &type, &format))
		return NULL;
	value = 0;
	ret = gst_element_query(GST_ELEMENT(self->obj), type, &format, &value);
	return Py_BuildValue("(bL)", ret, value);
}
%%
override gst_pad_convert kwargs

static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value", "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOi:GstPad.convert", kwlist, &src_format, &src_value_obj, &dest_format))
		return NULL;
	src_value = PyLong_AsLongLong(src_value_obj);
	dest_value = 0;
	ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value, &dest_format, &dest_value);
	return Py_BuildValue("(bL)", ret, dest_value);
}
%%
override gst_element_convert kwargs

static PyObject *
_wrap_gst_element_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "src_format", "src_value", "dest_format", NULL };
	GstFormat src_format, dest_format;
	PyObject *src_value_obj;
	gint64 src_value, dest_value;
	gboolean ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOi:GstElement.convert", kwlist, &src_format, &src_value_obj, &dest_format))
		return NULL;
	src_value = PyLong_AsLongLong(src_value_obj);
	dest_value = 0;
	ret = gst_element_convert(GST_ELEMENT(self->obj), src_format, src_value, &dest_format, &dest_value);
	return Py_BuildValue("(bL)", ret, dest_value);
}
%%
override gst_props_entry_get_int

static PyObject *
_wrap_gst_props_entry_get_int(PyObject *self)
{
	gboolean ret;
	gint val;

	val = 0;
	ret = gst_props_entry_get_int(pyg_boxed_get(self, GstPropsEntry), &val);
	return Py_BuildValue("(bi)", ret, val);
}
%%
override gst_props_entry_get_float

static PyObject *
_wrap_gst_props_entry_get_float(PyObject *self)
{
	gboolean ret;
	gfloat val;

	val = 0.0f;
	ret = gst_props_entry_get_float(pyg_boxed_get(self, GstPropsEntry), &val);
	return Py_BuildValue("(bf)", ret, val);
}
%%
override gst_props_entry_get_fourcc_int

static PyObject *
_wrap_gst_props_entry_get_fourcc_int(PyObject *self)
{
	gboolean ret;
	gint32 val;

	val = 0;
	ret = gst_props_entry_get_fourcc_int(pyg_boxed_get(self, GstPropsEntry), &val);
	return Py_BuildValue("(bi)", ret, val);
}
%%
override gst_props_entry_get_boolean

static PyObject *
_wrap_gst_props_entry_get_boolean(PyObject *self)
{
	gboolean ret;
	gboolean val;
	PyObject *py_val;

	val = FALSE;
	ret = gst_props_entry_get_boolean(pyg_boxed_get(self, GstPropsEntry), &val);
	
	py_val = val ? Py_True : Py_False;
	return Py_BuildValue("(bO)", ret, py_val);
}
%%
override gst_props_entry_get_string

static PyObject *
_wrap_gst_props_entry_get_string(PyObject *self)
{
	gboolean ret;
	const gchar *val;

	val = NULL;
	ret = gst_props_entry_get_string(pyg_boxed_get(self, GstPropsEntry), &val);
	if (ret) {
		return Py_BuildValue("(bs)", ret, val);
	} else {
		return Py_BuildValue("(bO)", ret, Py_None);
	}
}
%%
override gst_props_entry_get_int_range

static PyObject *
_wrap_gst_props_entry_get_int_range(PyObject *self)
{
	gboolean ret;
	gint min, max;

	min = max = 0;
	ret = gst_props_entry_get_int_range(pyg_boxed_get(self, GstPropsEntry), &min, &max);
	return Py_BuildValue("(bii)", ret, min, max);
}
%%
override gst_props_entry_get_float_range

static PyObject *
_wrap_gst_props_entry_get_float_range(PyObject *self)
{
	gboolean ret;
	gfloat min, max;

	min = max = 0.0f;
	ret = gst_props_entry_get_float_range(pyg_boxed_get(self, GstPropsEntry), &min, &max);
	return Py_BuildValue("(bff)", ret, min, max);
}
%%
override gst_props_entry_get_list



static PyObject *
_wrap_gst_props_entry_get_list(PyObject *self)
{
	gboolean ret;
	const GList *list;
	PyObject *tuple, *obj;
	int i;

	list = NULL;
	ret = gst_props_entry_get_list(pyg_boxed_get(self, GstPropsEntry), &list);
	if (ret == TRUE) {
		tuple = PyTuple_New(g_list_length((GList *) list));
		for (i = 0; list != NULL; i++, list = g_list_next(list)) {
			obj = pyg_boxed_new(GST_TYPE_PROPS_ENTRY, list->data, TRUE, TRUE);
			PyTuple_SET_ITEM(tuple, i, obj);
		}
	} else {
		tuple = Py_None;
		Py_INCREF(tuple);
	}
	return Py_BuildValue("(bO)", ret, tuple);
}
%%
override gst_props_get_list

static gboolean
gst_props_get_list(GstProps *props, GList **list)
{
	*list = GST_PROPS_PROPERTIES(props);
	return TRUE;
}

static PyObject *
_wrap_gst_props_get_list(PyObject *self)
{
	gboolean ret;
	GList *list;
	PyObject *tuple, *obj;
	int i;

	list = NULL;
	ret = gst_props_get_list(pyg_boxed_get(self, GstProps), &list);
	if (ret == TRUE) {
		tuple = PyTuple_New(g_list_length(list));
		for (i = 0; list != NULL; i++, list = g_list_next(list)) {
			obj = pyg_boxed_new(GST_TYPE_PROPS_ENTRY, list->data, TRUE, TRUE);
			PyTuple_SET_ITEM(tuple, i, obj);
		}
	} else {
		tuple = Py_None;
		Py_INCREF(tuple);
	}
	return Py_BuildValue("(bO)", ret, tuple);
}


%%
override gst_element_factory_make_element

/* we create this function to serve as a constructor for Element */
static int
_wrap_gst_element_factory_make_element(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "factoryname", "name", NULL };
    char *factoryname, *name;
                                                                                
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ss:GstElement.__init__", kwlist, &factoryname, &name))
        return -1;
    self->obj = (GObject *)gst_element_factory_make(factoryname, name);
                                                                                
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GstElement object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gst_version

static PyObject *
_wrap_gst_version(PyGObject *self)
{
	guint major, minor, micro;

	gst_version(&major, &minor, &micro);

	return Py_BuildValue("(iii)", major, minor, micro);
}
